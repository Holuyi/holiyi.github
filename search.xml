<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试评论</title>
      <link href="/2020/07/22/%E6%B5%8B%E8%AF%95%E8%AF%84%E8%AE%BA/"/>
      <url>/2020/07/22/%E6%B5%8B%E8%AF%95%E8%AF%84%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h5 id="测试评论"><a href="#测试评论" class="headerlink" title="测试评论"></a>测试评论</h5><p>在下面评论</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与并发2</title>
      <link href="/2020/07/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%912/"/>
      <url>/2020/07/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%912/</url>
      
        <content type="html"><![CDATA[<p>承接上文: <a href="https://holuyi.github.io/2020/07/22/多线程与并发1">多线程与并发1</a></p><h3 id="一-多线程的特性"><a href="#一-多线程的特性" class="headerlink" title="一. 多线程的特性"></a>一. 多线程的特性</h3><h4 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h4><p>原子性 , 即一个操作或多个操作要么全部执行并且执行过程中不会呗任何因素打断 , 要么就都不执行。</p><h4 id="2-有序性"><a href="#2-有序性" class="headerlink" title="2. 有序性"></a>2. 有序性</h4><p>有序性即程序执行的顺序按照代码的先后顺序执行。</p><h4 id="3-可见性"><a href="#3-可见性" class="headerlink" title="3. 可见性"></a>3. 可见性</h4><p>可见性是指当多个线程访问同一变量时 , 一个线程修改了这个变量的值 , 其它线程能够立即看得到修改的值。显然 , 对于单线程来说 , 可见性问题时不存在的。</p><h3 id="二-多线程控制类"><a href="#二-多线程控制类" class="headerlink" title="二. 多线程控制类"></a>二. 多线程控制类</h3><p>为了保证多线程的三个特性 , Java引入了很多线程控制机制 , 常用的有:</p><blockquote><p>ThreadLocal : 线程本地变量<br>原子类 : 保证变量原子操作<br>Lock类 : 保证线程有序性<br>volatile关键字 : 保证线程变量可见性</p></blockquote><h4 id="1-ThreadLocal"><a href="#1-ThreadLocal" class="headerlink" title="1. ThreadLocal"></a>1. ThreadLocal</h4><h5 id="1-作用"><a href="#1-作用" class="headerlink" title="(1) 作用"></a>(1) 作用</h5><p>ThreadLocal提供线程局部变量 , 即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域(在线程内起作用)并且不同线程具有不同的数据副本时 , 就可以考虑采用ThreadLocal。<br>比如数据库连接对象Connection , 每个请求处理线程都需要 , 但又不互相影响 , 就是用ThreadLocal实现。</p><h5 id="2-常用API"><a href="#2-常用API" class="headerlink" title="(2) 常用API"></a>(2) 常用API</h5><p>initalValue() : 副本创建方法<br>get() : 获取副本方法<br>set() : 设置副本方法</p><h5 id="3-示例"><a href="#3-示例" class="headerlink" title="(3) 示例"></a>(3) 示例</h5><p>假如有两个用户 , 同时向同一家银行存款 , 那么每个用户就会对应一个账户余额 , 账户余额这个值就适合以副本形式创建。<br>下面我们先来看运行代码:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author WuZhengHua</span></span><br><span class="line"><span class="comment"> * @describe ThreadLocal保证线程三大特性</span></span><br><span class="line"><span class="comment"> * @date 2020/03/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTransfer</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账进银行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bank  银行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Bank bank, Integer money)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"存钱中 ..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        bank.setMoney(money);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"存钱已存入 "</span> + money + <span class="string">"元"</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"当前余额 "</span> + bank.getMoney() + <span class="string">"元"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        BankTransfer bankTransfer = <span class="keyword">new</span> BankTransfer();</span><br><span class="line">        <span class="comment">//创建一个银行对象,两个用户都是同一个银行的</span></span><br><span class="line">        Bank bank = <span class="keyword">new</span> Bank();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="comment">//连续转3笔帐(每一笔100元)进银行,最后账户的余额应该是300元</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</span><br><span class="line">                    bankTransfer.transfer(bank, <span class="number">100</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"用户1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="comment">//连续转3笔帐(每一笔150元)进银行,最后账户的余额应该是450元</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</span><br><span class="line">                    bankTransfer.transfer(bank, <span class="number">150</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"用户2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果上面代码的Bank类结构如下:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Integer money = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存钱</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(Integer money)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.money += money;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取余额</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMoney</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.money;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我得到的输出结果为:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">用户<span class="number">1</span>存钱中 ...</span><br><span class="line">用户<span class="number">2</span>存钱中 ...</span><br><span class="line">用户<span class="number">2</span>存钱已存入 <span class="number">150</span>元</span><br><span class="line">用户<span class="number">1</span>存钱已存入 <span class="number">100</span>元</span><br><span class="line">用户<span class="number">1</span>当前余额 <span class="number">250</span>元</span><br><span class="line">用户<span class="number">2</span>当前余额 <span class="number">250</span>元</span><br><span class="line">用户<span class="number">1</span>存钱中 ...</span><br><span class="line">用户<span class="number">2</span>存钱中 ...</span><br><span class="line">用户<span class="number">1</span>存钱已存入 <span class="number">100</span>元</span><br><span class="line">用户<span class="number">1</span>当前余额 <span class="number">350</span>元</span><br><span class="line">用户<span class="number">1</span>存钱中 ...</span><br><span class="line">用户<span class="number">2</span>存钱已存入 <span class="number">150</span>元</span><br><span class="line">用户<span class="number">2</span>当前余额 <span class="number">500</span>元</span><br><span class="line">用户<span class="number">2</span>存钱中 ...</span><br><span class="line">用户<span class="number">2</span>存钱已存入 <span class="number">150</span>元</span><br><span class="line">用户<span class="number">2</span>当前余额 <span class="number">600</span>元</span><br><span class="line">用户<span class="number">1</span>存钱已存入 <span class="number">100</span>元</span><br><span class="line">用户<span class="number">1</span>当前余额 <span class="number">600</span>元</span><br></pre></td></tr></tbody></table></figure><p>明显余额结果不正确 , 用户1应该最后拥有300元 , 用户2拥有450元 , 这是因为在创建线程时共用一个Bank对象 , 所以两个用户的金额保存在同一份中 , 所以应该使用ThreadLocal创建副本来管理各自的金额:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>{</span><br><span class="line">    <span class="comment">//创建账户金额副本,并定义初始值0</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; money = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存钱</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(Integer money)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.money.set(getMoney() + money);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取余额</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMoney</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> money.get();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">用户<span class="number">2</span>存钱中 ...</span><br><span class="line">用户<span class="number">1</span>存钱中 ...</span><br><span class="line">用户<span class="number">2</span>存钱已存入 <span class="number">150</span>元</span><br><span class="line">用户<span class="number">1</span>存钱已存入 <span class="number">100</span>元</span><br><span class="line">用户<span class="number">2</span>当前余额 <span class="number">150</span>元</span><br><span class="line">用户<span class="number">2</span>存钱中 ...</span><br><span class="line">用户<span class="number">1</span>当前余额 <span class="number">100</span>元</span><br><span class="line">用户<span class="number">1</span>存钱中 ...</span><br><span class="line">用户<span class="number">2</span>存钱已存入 <span class="number">150</span>元</span><br><span class="line">用户<span class="number">2</span>当前余额 <span class="number">300</span>元</span><br><span class="line">用户<span class="number">2</span>存钱中 ...</span><br><span class="line">用户<span class="number">1</span>存钱已存入 <span class="number">100</span>元</span><br><span class="line">用户<span class="number">1</span>当前余额 <span class="number">200</span>元</span><br><span class="line">用户<span class="number">1</span>存钱中 ...</span><br><span class="line">用户<span class="number">2</span>存钱已存入 <span class="number">150</span>元</span><br><span class="line">用户<span class="number">1</span>存钱已存入 <span class="number">100</span>元</span><br><span class="line">用户<span class="number">1</span>当前余额 <span class="number">300</span>元</span><br><span class="line">用户<span class="number">2</span>当前余额 <span class="number">450</span>元</span><br></pre></td></tr></tbody></table></figure><h5 id="4-实现原理"><a href="#4-实现原理" class="headerlink" title="(4) 实现原理"></a>(4) 实现原理</h5><p>① 在ThreadLocal类中定义了一个ThreadLocalMap对象 , 该对象是线程独有的 , 每一个线程都有一个ThreadLocalMap类型的变量threadLocals。<br>② ThreadLocalMap内部有一个Entry对象 , Entry的key是ThreadLocal对象实例 , value就是共享变量副本。<br>③ ThreadLocal的get方法就是根据ThreadLocal对象实例获取存在于ThreadLocalMap中的共享变量副本。<br>③ ThreadLocal的set方法就是根据ThreadLocal对象实例修改存在于ThreadLocalMap中的共享变量副本。</p><h4 id="2-原子类"><a href="#2-原子类" class="headerlink" title="2. 原子类"></a>2. 原子类</h4><h5 id="1-简介和作用"><a href="#1-简介和作用" class="headerlink" title="(1) 简介和作用"></a>(1) 简介和作用</h5><p>Java的java.util.concurrent.atomic包里面提供了很多可以进行原子操作的类 , 分为以下四类:</p><blockquote><p>原子更新基本类型: AtomicInteger、AtomicBoolean、AtomicLong<br>原子更新数组类型: AtomicIntegerArray、AtomicLongArray<br>原子更新引用类型: AtomicReference、AtomicStampedReference等<br>原子更新属性类型: AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</p></blockquote><p>提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。</p><h5 id="2-示例"><a href="#2-示例" class="headerlink" title="(2) 示例"></a>(2) 示例</h5><p>i++操作是分为三个步骤的:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp1 = i;</span><br><span class="line"><span class="keyword">int</span> temp2 = temp1 + <span class="number">1</span>;</span><br><span class="line">i = temp2;</span><br></pre></td></tr></tbody></table></figure><p>所以在多个线程对同个i同时i++时可能会出现问题 , 比如下面代码的输出结果预期应该都是2000:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author WuZhengHua</span></span><br><span class="line"><span class="comment"> * @describe 原子类的使用</span></span><br><span class="line"><span class="comment"> * @date 2020/03/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicCtrl</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) {</span><br><span class="line">            Atomic atomic = <span class="keyword">new</span> Atomic();</span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread(atomic);</span><br><span class="line">            Thread thread2 = <span class="keyword">new</span> Thread(atomic);</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">            <span class="comment">//加入到主线程方便数值统计</span></span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">            System.out.println(<span class="string">"第"</span> + i + <span class="string">"次,n的值为: "</span> + atomic.getN());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Atomic</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getN</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">            n++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">第<span class="number">0</span>次,n的值为: <span class="number">2000</span></span><br><span class="line">第<span class="number">1</span>次,n的值为: <span class="number">1552</span></span><br><span class="line">第<span class="number">2</span>次,n的值为: <span class="number">2000</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>但是我们发现结果中有一些并不是2000 , 这就是因为i++操作不是原子操作。<br>这时候我们就可以使用原子类型: AtomicInteger 去代替int:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Atomic</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="comment">//创建原子整型 , 并初始化值为0</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger n = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AtomicInteger <span class="title">getN</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">            <span class="comment">//获取到值再自增对应 i++</span></span><br><span class="line">            n.getAndIncrement();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果 都是2000</span></span><br></pre></td></tr></tbody></table></figure><p>这里补充一些AtomicInteger的常用API:</p><blockquote><p>getAndIncrement() : 对应n++<br>incrementAndGet() : 对应++n<br>getAndDecrement() : 对应n–<br>decrementAndGet() : 对应–n</p></blockquote><h5 id="3-CAS原理"><a href="#3-CAS原理" class="headerlink" title="(3) CAS原理"></a>(3) CAS原理</h5><p>那么原子类型变量是如何实现原子操作的呢?答案就是CAS原理 , 我们来看看AtomicInteger的getAndIncrement()方法:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>unsafe是Sun公司提供的可以进行原子操作的工具类 , 这里getAndAddInt传入三个参数分别是: AtomicInteger实例this , 地址偏移量valueOffset , 增加阶数1<br>下面我们来看看unsafe.getAndAddInt()方法:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    } <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解释一下上面的几个参数:<br>var1 : 是当前值n<br>var2 : 是地址偏移量<br>var5 : 是n的期望值(这里就是加1之后的值)<br>var4 : 递增间隔(这里是1)<br>CAS(比较并交换)原理:</p><blockquote><p>① getIntVolatile()方法是根据当前值和地址偏移量获取Java堆中的期望值。<br>② compareAndSwapInt()方法是比对 当前值(var1) 和期望值(var5) 是否相同:<br>i 如果相同 , 说明线程更改过该值 , 当前值(var1) = 期望值(var5) + 递增间隔(var4) , 返回true。<br>ii 如果不同 , 说明线程没有更改过该值 , 当前值(var1) = 期望值(var5) , 返回false。</p></blockquote><h4 id="3-Lock"><a href="#3-Lock" class="headerlink" title="3. Lock"></a>3. Lock</h4><h5 id="1-可重入锁与不可重入锁"><a href="#1-可重入锁与不可重入锁" class="headerlink" title="(1) 可重入锁与不可重入锁"></a>(1) 可重入锁与不可重入锁</h5><p>不可重入锁: 线程多次请求它已经拥有的锁时会发生阻塞。<br>可重入锁: 线程可以进入它已经拥有的锁的同步代码块。</p><h5 id="2-读写锁"><a href="#2-读写锁" class="headerlink" title="(2) 读写锁"></a>(2) 读写锁</h5><p>多个线程可以同时读，读的时候不能写。<br>多个线程不能同时写，写的时候不能读。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author WuZhengHua</span></span><br><span class="line"><span class="comment"> * @describe 测试读写锁</span></span><br><span class="line"><span class="comment"> * @date 2020/04/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//定义读写锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">//获取读操作锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();</span><br><span class="line">    <span class="comment">//获取写操作锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>{</span><br><span class="line">        readLock.lock();    <span class="comment">//读操作加锁</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 读操作已加锁, 开始执行读操作..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            readLock.unlock();  <span class="comment">//解锁</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 读操作已解锁, 读操作结束..."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>{</span><br><span class="line">        writeLock.lock();    <span class="comment">//写操作加锁</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 写操作已加锁, 开始执行写操作..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            writeLock.unlock();  <span class="comment">//解锁</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 写操作已解锁, 写操作结束..."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> ReadWriteLockDemo readWriteLockDemo = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"写线程1"</span>) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                readWriteLockDemo.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"读线程1"</span>) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(readWriteLockDemo.get(<span class="string">"key1"</span>));</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"写线程2"</span>) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                readWriteLockDemo.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"读线程2"</span>) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(readWriteLockDemo.get(<span class="string">"key1"</span>));</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"读线程3"</span>) {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(readWriteLockDemo.get(<span class="string">"key1"</span>));</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">写线程<span class="number">1</span> 写操作已加锁, 开始执行写操作...</span><br><span class="line">写线程<span class="number">1</span> 写操作已解锁, 写操作结束...</span><br><span class="line">读线程<span class="number">1</span> 读操作已加锁, 开始执行读操作...</span><br><span class="line">读线程<span class="number">1</span> 读操作已解锁, 读操作结束...</span><br><span class="line">value1</span><br><span class="line">写线程<span class="number">2</span> 写操作已加锁, 开始执行写操作...</span><br><span class="line">写线程<span class="number">2</span> 写操作已解锁, 写操作结束...</span><br><span class="line">读线程<span class="number">2</span> 读操作已加锁, 开始执行读操作...</span><br><span class="line">读线程<span class="number">3</span> 读操作已加锁, 开始执行读操作...</span><br><span class="line">读线程<span class="number">3</span> 读操作已解锁, 读操作结束...</span><br><span class="line">value1</span><br><span class="line">读线程<span class="number">2</span> 读操作已解锁, 读操作结束...</span><br><span class="line">value1</span><br></pre></td></tr></tbody></table></figure><h4 id="4-volatile关键字"><a href="#4-volatile关键字" class="headerlink" title="4. volatile关键字"></a>4. volatile关键字</h4><h5 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="(1) 作用"></a>(1) 作用</h5><p>一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义:</p><blockquote><p>① 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其它线程来说是立即可见的。<br>② 禁止进行指令重排序</p></blockquote><p>补充一下何为指令重排序:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line">i = <span class="number">3</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果变量i没有被volatile修饰，那么JVM在编译期会对代码进行优化，即i = 1;和i = 2;这两句代码是无效的，会直接忽略掉。进行了指令重排序。<br>但是如果i被volatile修饰，有关i操作的代码都会被严格执行。这就是禁止了指令重排序。</p><h5 id="2-使用条件"><a href="#2-使用条件" class="headerlink" title="(2) 使用条件"></a>(2) 使用条件</h5><p>① 对变量的写操作不依赖于当前值</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误例子</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = i + <span class="number">1</span>;<span class="comment">//这里对于i的写操作依赖了i，所以不能使用volatile关键字修饰</span></span><br></pre></td></tr></tbody></table></figure><p>② 该变量没有包含在具有其它变量的不变式中</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误例子</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">j = i + j;<span class="comment">//这里j和i同时出现在不变式中，不能使用volatile关键字修饰</span></span><br></pre></td></tr></tbody></table></figure><h5 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="(3) 应用场景"></a>(3) 应用场景</h5><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与并发1</title>
      <link href="/2020/07/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%911/"/>
      <url>/2020/07/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%911/</url>
      
        <content type="html"><![CDATA[<h3 id="一-并行与并发"><a href="#一-并行与并发" class="headerlink" title="一. 并行与并发"></a>一. 并行与并发</h3><p>并行: 两个事件<strong>同一时间</strong>时进行<br>并发: 两个事件<strong>同个时间</strong>段内进行</p><h3 id="二-进程与线程"><a href="#二-进程与线程" class="headerlink" title="二. 进程与线程"></a>二. 进程与线程</h3><p>进程: 正在运行的程序的实例 , 进程是线程的容器。<br>线程: 进程内部的一个独立执行单元 , 每个进程可以并发多个线程组成。<br>多线程: 多个线程并发执行。</p><h3 id="三-线程创建"><a href="#三-线程创建" class="headerlink" title="三. 线程创建"></a>三. 线程创建</h3><h4 id="Java中的四种线程创建方式"><a href="#Java中的四种线程创建方式" class="headerlink" title="Java中的四种线程创建方式:"></a>Java中的四种线程创建方式:</h4><blockquote><p>继承Thread类<br>实现Runnable接口<br>实现Callable接口<br>线程池</p></blockquote><h4 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author WuZhengHua</span></span><br><span class="line"><span class="comment"> * @describe 继承Thread创建线程</span></span><br><span class="line"><span class="comment"> * @date 2020/03/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">" MyThread执行了: "</span> + <span class="keyword">new</span> Date().getTime());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);   <span class="comment">//当前线程睡眠50ms</span></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">" 主线程执行了: "</span> + <span class="keyword">new</span> Date().getTime());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);   <span class="comment">//当前线程睡眠50ms</span></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"> MyThread执行了: <span class="number">1585035565928</span></span><br><span class="line"> 主线程执行了: <span class="number">1585035565928</span></span><br><span class="line"> 主线程执行了: <span class="number">1585035565982</span></span><br><span class="line"> MyThread执行了: <span class="number">1585035565982</span></span><br><span class="line"> MyThread执行了: <span class="number">1585035566044</span></span><br><span class="line"> 主线程执行了: <span class="number">1585035566044</span></span><br><span class="line"> MyThread执行了: <span class="number">1585035566098</span></span><br><span class="line"> 主线程执行了: <span class="number">1585035566098</span></span><br><span class="line"> 主线程执行了: <span class="number">1585035566160</span></span><br><span class="line"> MyThread执行了: <span class="number">1585035566160</span></span><br><span class="line"> 主线程执行了: <span class="number">1585035566214</span></span><br><span class="line"> MyThread执行了: <span class="number">1585035566214</span></span><br><span class="line"> MyThread执行了: <span class="number">1585035566283</span></span><br><span class="line"> 主线程执行了: <span class="number">1585035566283</span></span><br><span class="line"> 主线程执行了: <span class="number">1585035566345</span></span><br><span class="line"> MyThread执行了: <span class="number">1585035566345</span></span><br><span class="line"> MyThread执行了: <span class="number">1585035566399</span></span><br><span class="line"> 主线程执行了: <span class="number">1585035566399</span></span><br><span class="line"> 主线程执行了: <span class="number">1585035566461</span></span><br><span class="line"> MyThread执行了: <span class="number">1585035566461</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author WuZhengHua</span></span><br><span class="line"><span class="comment"> * @describe 实现Runnable接口创建线程</span></span><br><span class="line"><span class="comment"> * @date 2020/03/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"MyRunnable线程执行了"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//传入Runnable实现类和自定义线程名称</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(),<span class="string">"MyRunnable"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">MyRunnable线程执行了</span><br></pre></td></tr></tbody></table></figure><h4 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3. 实现Callable接口"></a>3. 实现Callable接口</h4><p>这种方式创建的线程需要依赖FutureTask类 , 与上面两个不同的是 , 该方式可以获得线程执行完之后的返回值。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author WuZhengHua</span></span><br><span class="line"><span class="comment"> * @describe 实现Callable接口创建线程</span></span><br><span class="line"><span class="comment"> * @date 2020/03/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"MyCallable线程执行了"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MyCallable-return"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        futureTask.run();</span><br><span class="line">        Object o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            o = futureTask.get();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">MyCallable线程执行了</span><br><span class="line">MyCallable-<span class="keyword">return</span></span><br></pre></td></tr></tbody></table></figure><h4 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h4><p>首先我们来了解一下什么是线程池 , 以及其内部有什么构成:</p><p><img src="http://free-cn-01.cdn.bilnn.com/ddimg/jfs/t1/87925/33/16317/20014/5e79ac56E93d7258a/b8eebe852cf170a7.png" alt="img"></p><p>Java提供了线程池以及操作线程池的工具类 , 这些类的关系如下:</p><p><img src="http://free-cn-01.cdn.bilnn.com/ddimg/jfs/t1/105425/20/16333/33419/5e79be5fE888926ac/ab3d40ad0dc47541.png" alt="img"></p><p>通过线程池创建对象:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author WuZhengHua</span></span><br><span class="line"><span class="comment"> * @describe 通过线程池创建对象</span></span><br><span class="line"><span class="comment"> * @date 2020/03/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//FixedThreadPool固定线程数的线程池 , 这里创建一个10个线程的线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyRunnable());  <span class="comment">//创建线程 , 传入线程</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="四-线程的状态"><a href="#四-线程的状态" class="headerlink" title="四. 线程的状态"></a>四. 线程的状态</h3><p>学过操作系统这门课的同学应该都知道 , 线程分为五个状态: 初始状态-就绪状态-运行状态-阻塞状态-终止状态 , 下面我用一幅图来说明这五个状态的关系(图片出自&lt;&lt;码出高效 Java开发手册&gt;&gt;)</p><p><img src="http://free-cn-01.cdn.bilnn.com/ddimg/jfs/t1/85475/28/16249/38927/5e79a84aEd17e7d4c/d38b705513db6951.png" alt="img"></p><h3 id="五-线程安全问题"><a href="#五-线程安全问题" class="headerlink" title="五. 线程安全问题"></a>五. 线程安全问题</h3><p>如果一段代码单线程运行的结果跟多线程运行的结果不一致 , 就说明这个多线程存在安全问题 , 在开发中我们要避免这种线程安全问题 , 看一段代码:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author WuZhengHua</span></span><br><span class="line"><span class="comment"> * @describe 票类,可以执行卖票操作</span></span><br><span class="line"><span class="comment"> * @date 2020/03/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> amount = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//不停卖票</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span>(amount &lt;= <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//售卖电影票</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//让线程睡眠100ms</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//打印售出的电影票编号 , 并且数量减</span></span><br><span class="line">            String name = Thread.currentThread().getName(); <span class="comment">//获取到线程名称</span></span><br><span class="line">            System.out.println(name + <span class="string">"售出电影票,编号: "</span> + amount--);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口2"</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">...</span><br><span class="line">窗口<span class="number">2</span>售出电影票,编号: <span class="number">10</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">8</span></span><br><span class="line">窗口<span class="number">3</span>售出电影票,编号: <span class="number">9</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">7</span></span><br><span class="line">窗口<span class="number">3</span>售出电影票,编号: <span class="number">5</span></span><br><span class="line">窗口<span class="number">2</span>售出电影票,编号: <span class="number">6</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">4</span></span><br><span class="line">窗口<span class="number">2</span>售出电影票,编号: <span class="number">3</span></span><br><span class="line">窗口<span class="number">3</span>售出电影票,编号: <span class="number">4</span></span><br><span class="line">窗口<span class="number">3</span>售出电影票,编号: <span class="number">2</span></span><br><span class="line">窗口<span class="number">2</span>售出电影票,编号: <span class="number">1</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">0</span></span><br><span class="line">窗口<span class="number">3</span>售出电影票,编号: -<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>从结果中我们看出 , 有些电影票被卖了多次(显然不符合逻辑) , 到最后甚至出现了0和-1的情况 , 原因就是因为Ticket类的amount变量被肆无忌惮地修改了 , 多个线程对共享数据同时具有写操作就是多线程安全问题。</p><h3 id="六-解决线程安全问题"><a href="#六-解决线程安全问题" class="headerlink" title="六. 解决线程安全问题"></a>六. 解决线程安全问题</h3><p>Java给我们提供了七种多线程同步的方式 , 这里我使用上面的例子来解决线程安全问题:</p><h4 id="1-同步代码块-synchronized"><a href="#1-同步代码块-synchronized" class="headerlink" title="1.同步代码块(synchronized)"></a>1.同步代码块(synchronized)</h4><p>创建一个锁对象 , 该对象可以理解为钥匙 , 一旦钥匙被某个线程拿到 , 其它线程就无法执行同步代码块 , 关键代码实现如下:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个锁对象,相当于钥匙</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//使用同步代码块,这里传进去一个锁对象</span></span><br><span class="line">    <span class="keyword">synchronized</span> (object) {</span><br><span class="line">        <span class="comment">//不停卖票</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span>(amount &lt;= <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }            </span><br><span class="line">            <span class="comment">//售卖电影票</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//让线程睡眠100ms</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//打印售出的电影票编号 , 并且数量减</span></span><br><span class="line">            String name = Thread.currentThread().getName(); <span class="comment">//获取到线程名称</span></span><br><span class="line">            System.out.println(name + <span class="string">"售出电影票,编号: "</span> + amount--);</span><br><span class="line">        }</span><br><span class="line">    }        </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">...</span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">7</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">6</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">5</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">4</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">3</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">2</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>这里锁对象被第一个线程(窗口1)拿到了 , 且循环过程中没有释放过锁对象 , 所以其它线程就无法执行同步代码块中的代码(变成单线程执行)。</p><h4 id="2-同步方法-synchronized"><a href="#2-同步方法-synchronized" class="headerlink" title="2.同步方法(synchronized)"></a>2.同步方法(synchronized)</h4><p>synchronized关键字也可以修饰方法(静态方法和非静态方法都可以) , 我们在上面代码的基础上定义一个同步方法:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在方法前加synchronized关键字 ,</span></span><br><span class="line"><span class="comment"> * 本质上也是创建了一个锁对象</span></span><br><span class="line"><span class="comment"> * 如果该方法是非静态方法,锁对象就是当前方法的实例new Ticket()</span></span><br><span class="line"><span class="comment"> * 如果该方法时静态方法,锁对象就是当前静态方法所在的类Ticket.class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(amount &lt;= <span class="number">0</span>){</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//售卖电影票</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">//让线程睡眠100ms</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//打印售出的电影票编号 , 并且数量减</span></span><br><span class="line">    String name = Thread.currentThread().getName(); <span class="comment">//获取到线程名称</span></span><br><span class="line">    System.out.println(name + <span class="string">"售出电影票,编号: "</span> + amount--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        <span class="comment">//这个方法就是只允许一个线程访问的同步方法</span></span><br><span class="line">        saleTicket();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">...</span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">7</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">6</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">5</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">4</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">3</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">2</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h4 id="3-同步锁"><a href="#3-同步锁" class="headerlink" title="3.同步锁"></a>3.同步锁</h4><p>通过上面两种方式 , 都是使用一个锁对象进行线程同步的 , Java为了优化这种同步方式, 可以检测锁的状态 , 体现面向对象 , 也提供了锁的机制 。<br>Java提供了很多种锁 , 这里我们先以重入锁(ReenreantLock)为例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建重入锁 , 参数标识是否为公平锁 ,</span></span><br><span class="line"><span class="comment"> * 这里设置为公平锁 , 每个线程都公平拥有执行权 , 所有线程都可以主动拿到这个锁</span></span><br><span class="line"><span class="comment"> * 非公平锁(独占锁) , 默认值 , 一旦某个线程拿到锁之后就一直持有执行权直到主动释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 加锁方法 , 这个方法跟解锁方法unlock必须要成对出现 , 否则会出现死锁</span></span><br><span class="line"><span class="comment">     * 所以我们经常使用try-finally语句块去保证不会出现死锁现象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//不停卖票,直到数量为0</span></span><br><span class="line">            <span class="keyword">if</span>(amount &lt;= <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//售卖电影票</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//让线程睡眠100ms</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//打印售出的电影票编号 , 并且数量减</span></span><br><span class="line">            String name = Thread.currentThread().getName(); <span class="comment">//获取到线程名称</span></span><br><span class="line">            System.out.println(name + <span class="string">"售出电影票,编号: "</span> + amount--);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//执行解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">...</span><br><span class="line">窗口<span class="number">3</span>售出电影票,编号: <span class="number">8</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">7</span></span><br><span class="line">窗口<span class="number">2</span>售出电影票,编号: <span class="number">6</span></span><br><span class="line">窗口<span class="number">3</span>售出电影票,编号: <span class="number">5</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">4</span></span><br><span class="line">窗口<span class="number">2</span>售出电影票,编号: <span class="number">3</span></span><br><span class="line">窗口<span class="number">3</span>售出电影票,编号: <span class="number">2</span></span><br><span class="line">窗口<span class="number">1</span>售出电影票,编号: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h4 id="4-特殊域变量-volatile"><a href="#4-特殊域变量-volatile" class="headerlink" title="4.特殊域变量(volatile)"></a>4.特殊域变量(volatile)</h4><h4 id="5-局部变量-ThreadLocal"><a href="#5-局部变量-ThreadLocal" class="headerlink" title="5.局部变量(ThreadLocal)"></a>5.局部变量(ThreadLocal)</h4><h4 id="6-阻塞队列-LinkedBlockingQueue"><a href="#6-阻塞队列-LinkedBlockingQueue" class="headerlink" title="6.阻塞队列(LinkedBlockingQueue)"></a>6.阻塞队列(LinkedBlockingQueue)</h4><h4 id="7-原子变量-Atomic"><a href="#7-原子变量-Atomic" class="headerlink" title="7.原子变量(Atomic*)"></a>7.原子变量(Atomic*)</h4><h3 id="七-线程死锁"><a href="#七-线程死锁" class="headerlink" title="七. 线程死锁"></a>七. 线程死锁</h3><h4 id="1-什么是死锁"><a href="#1-什么是死锁" class="headerlink" title="1. 什么是死锁"></a>1. 什么是死锁</h4><p>死锁是指多个线程因竞争资源而造成的一种僵局(互相等待) , 若无外力作用 , 这些进程都将无法向前推进。</p><h4 id="2-死锁产生的必要条件"><a href="#2-死锁产生的必要条件" class="headerlink" title="2. 死锁产生的必要条件"></a>2. 死锁产生的必要条件</h4><p>(1) 互斥条件<br>进程要求对所分配的资源(如打印机)进行排他性控制 , 即在一段时间内某资源仅为一个线程所占有。此时若有其它线程请求该资源 , 则请求进程只能等待。<br>(2) 不可剥夺条件<br>进程所获得的资源在未使用完毕之前 , 不能被其他线程强行夺走 , 即只能由获得该资源的进程自己来释放(只能主动释放)。<br>(3) 请求与保持条件<br>进程已经保持了至少一个资源 , 但又提出了新的资源请求 , 而该资源已被其他进程占有 , 此时请求进程被阻塞 , 但对自己已获得的资源保持不放。<br>(4) 循环等待条件<br>存在一种进程资源的循环等待链 , 链中每一个进程已获得的资源同时被链中下一个进程所请求。</p><h3 id="八-线程通讯"><a href="#八-线程通讯" class="headerlink" title="八. 线程通讯"></a>八. 线程通讯</h3><h4 id="1-为什么要使用线程通讯"><a href="#1-为什么要使用线程通讯" class="headerlink" title="1. 为什么要使用线程通讯"></a>1. 为什么要使用线程通讯</h4><p>多线程并发执行时 , 默认情况下CPU是随机切换线程执行的 , 有时我们希望CPU按照我们安排的规律去执行线程 , 这时就需要线程之间协调通信。</p><h4 id="2-线程通讯方式"><a href="#2-线程通讯方式" class="headerlink" title="2. 线程通讯方式"></a>2. 线程通讯方式</h4><p>线程间通讯常用方式有四种:</p><h5 id="1-休眠唤醒方式"><a href="#1-休眠唤醒方式" class="headerlink" title="(1) 休眠唤醒方式"></a>(1) 休眠唤醒方式</h5><p>① Object 的 wait()、notify()、notifyAll()<br>② Condition 的 await()、signal()、signalAll()</p><p><strong>案例:</strong> 创建两个线程 , 一个线程打印0-10以内的奇数 , 另一个线程打印0-10以内的偶数 , 两个线程按1-10的顺序交替打印。</p><p><strong>① 使用Object实现</strong></p><p>使用Object的wait()和notify()实现线程休眠和唤醒依赖synchronized关键字 , Object就是锁对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放待打印的数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//使用Object的方法进行休眠唤醒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奇数打印方法 , 由奇数线程调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注意这里别忘了使用synchronized关键字</span></span><br><span class="line"><span class="comment">         * 不然会报异常java.lang.IllegalMonitorStateException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) {</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">//奇数,输出出来并加一</span></span><br><span class="line">                System.out.println(<span class="string">"奇数: "</span> + i++);</span><br><span class="line">                <span class="comment">//唤醒偶数线程</span></span><br><span class="line">                obj.notify();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">//等待偶数线程执行</span></span><br><span class="line">                    obj.wait();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//..偶数打印方法类似,这里省略了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="comment">//创建当前实例</span></span><br><span class="line">    <span class="keyword">final</span> PrintOddAndEven printOddAndEven = <span class="keyword">new</span> PrintOddAndEven();</span><br><span class="line">    <span class="comment">//开启奇数线程</span></span><br><span class="line">    Thread oddThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            printOddAndEven.odd();</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="comment">//开启偶数线程</span></span><br><span class="line">    Thread evenThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            printOddAndEven.even();</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    oddThread.start();</span><br><span class="line">    evenThread.start();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">偶数: <span class="number">0</span></span><br><span class="line">奇数: <span class="number">1</span></span><br><span class="line">偶数: <span class="number">2</span></span><br><span class="line">奇数: <span class="number">3</span></span><br><span class="line">偶数: <span class="number">4</span></span><br><span class="line">奇数: <span class="number">5</span></span><br><span class="line">偶数: <span class="number">6</span></span><br><span class="line">奇数: <span class="number">7</span></span><br><span class="line">偶数: <span class="number">8</span></span><br><span class="line">奇数: <span class="number">9</span></span><br></pre></td></tr></tbody></table></figure><p><strong>② 使用Condition对象</strong></p><p>Condition是依赖Lock对象进行线程休眠和唤醒的 , 这也是跟Object方式的区别 , 同样使用上面的例子 , 改用Condition进行线程休眠唤醒 , 参照上例 , 部分代码如下:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Lock对象,注意这里是非公平锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 奇数打印方法 , 由奇数线程调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">10</span>) {</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">//奇数,输出出来并加一</span></span><br><span class="line">                System.out.println(<span class="string">"奇数: "</span> + i++);</span><br><span class="line">                <span class="comment">//唤醒偶数线程</span></span><br><span class="line">                condition.signal();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">//等待偶数线程执行</span></span><br><span class="line">                    condition.await();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">偶数: <span class="number">0</span></span><br><span class="line">奇数: <span class="number">1</span></span><br><span class="line">偶数: <span class="number">2</span></span><br><span class="line">奇数: <span class="number">3</span></span><br><span class="line">偶数: <span class="number">4</span></span><br><span class="line">奇数: <span class="number">5</span></span><br><span class="line">偶数: <span class="number">6</span></span><br><span class="line">奇数: <span class="number">7</span></span><br><span class="line">偶数: <span class="number">8</span></span><br><span class="line">奇数: <span class="number">9</span></span><br></pre></td></tr></tbody></table></figure><h5 id="2-CountDownLatch"><a href="#2-CountDownLatch" class="headerlink" title="(2) CountDownLatch"></a>(2) CountDownLatch</h5><p>用于某个线程A等待若干其它线程执行完之后 , 它才执行。<em>(即一等多)</em><br>案例: 一个教练等待三个运动员准备完成再开始训练</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author WuZhengHua</span></span><br><span class="line"><span class="comment"> * @describe CountDownLatch的使用</span></span><br><span class="line"><span class="comment"> * @date 2020/03/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoachWaitRacer</span> </span>{</span><br><span class="line">    <span class="comment">//创建CountDownLatch对象,构造函数需要传入需要等待的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 教练</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coach</span><span class="params">()</span> </span>{</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(name + <span class="string">"准备完毕,等待运动员..."</span>);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(<span class="string">"运动员全部到齐,开始训练!"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运动员</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">racer</span><span class="params">()</span> </span>{</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name + <span class="string">"开始准备..."</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(name + <span class="string">"准备完毕!"</span>);</span><br><span class="line">            <span class="comment">//调用计数器减一</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> CoachWaitRacer coachWaitRacer = <span class="keyword">new</span> CoachWaitRacer();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                coachWaitRacer.coach();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"教练"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                coachWaitRacer.racer();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"运动员1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                coachWaitRacer.racer();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"运动员2"</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                coachWaitRacer.racer();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"运动员3"</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">运动员<span class="number">1</span>开始准备...</span><br><span class="line">运动员<span class="number">3</span>开始准备...</span><br><span class="line">运动员<span class="number">2</span>开始准备...</span><br><span class="line">运动员<span class="number">2</span>准备完毕!</span><br><span class="line">教练准备完毕,等待运动员...</span><br><span class="line">运动员<span class="number">1</span>准备完毕!</span><br><span class="line">运动员<span class="number">3</span>准备完毕!</span><br><span class="line">运动员全部到齐,开始训练!</span><br></pre></td></tr></tbody></table></figure><h5 id="3-CyclicBarrier"><a href="#3-CyclicBarrier" class="headerlink" title="(3) CyclicBarrier"></a>(3) CyclicBarrier</h5><p>一组线程等待至某个状态之后再全部执行。<em>(同时阻塞)</em><br>案例: 运动员准备完成都到了起跑线才能开始比赛。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author WuZhengHua</span></span><br><span class="line"><span class="comment"> * @describe CyclicBarrier的使用</span></span><br><span class="line"><span class="comment"> * @date 2020/03/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RacerGo</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建cyclicBarrier对象,传入线程组的线程数,即需要互相等待的线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">racerStart</span><span class="params">()</span> </span>{</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(name + <span class="string">"准备完毕"</span>);</span><br><span class="line">            <span class="comment">//调用await方法,只有当三个线程到达同一状态时才继续往下执行(即三个线程都执行到该方法)</span></span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date().getTime() + <span class="string">" 跑!"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> RacerGo racerGo = <span class="keyword">new</span> RacerGo();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                racerGo.racerStart();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"运动员1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                racerGo.racerStart();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"运动员2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                racerGo.racerStart();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"运动员3"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">运动员<span class="number">2</span>准备完毕</span><br><span class="line">运动员<span class="number">3</span>准备完毕</span><br><span class="line">运动员<span class="number">1</span>准备完毕</span><br><span class="line"><span class="number">1585233005512</span> 跑!</span><br><span class="line"><span class="number">1585233005512</span> 跑!</span><br><span class="line"><span class="number">1585233005512</span> 跑!</span><br></pre></td></tr></tbody></table></figure><h5 id="4-Semaphore"><a href="#4-Semaphore" class="headerlink" title="(4) Semaphore"></a>(4) Semaphore</h5><p>用于控制对某组资源的访问权限。<br>案例: 假如有5个工人 , 3台机器 , 每台机器只允许一人使用。即5个线程使用3个资源 , 每个资源只能由一个线程占有。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @author WuZhengHua</span></span><br><span class="line"><span class="comment"> * @describe Semaphore的使用</span></span><br><span class="line"><span class="comment"> * @date 2020/03/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkersAndMachine</span> </span>{</span><br><span class="line">    Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>); <span class="comment">//三台机器,三个资源</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工人工作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>{</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name + <span class="string">"准备工作,请求一台机器 "</span>+<span class="keyword">new</span> Date().getTime());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//请求一个资源</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(name+<span class="string">"拿到机器,开始工作... "</span>+<span class="keyword">new</span> Date().getTime());</span><br><span class="line">            <span class="comment">//工作了1000ms</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="comment">//使用完毕,释放一个资源</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(name + <span class="string">"完成工作,释放机器! "</span>+<span class="keyword">new</span> Date().getTime());</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> WorkersAndMachine workersAndMachine = <span class="keyword">new</span> WorkersAndMachine();</span><br><span class="line">        <span class="comment">//5个工人,创建5个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) {</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    workersAndMachine.doWork();</span><br><span class="line">                }</span><br><span class="line">            }, <span class="string">"工人"</span> + i).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">工人<span class="number">1</span>准备工作,请求一台机器 <span class="number">1585323284818</span></span><br><span class="line">工人<span class="number">2</span>准备工作,请求一台机器 <span class="number">1585323284818</span></span><br><span class="line">工人<span class="number">1</span>拿到机器,开始工作... <span class="number">1585323284818</span></span><br><span class="line">工人<span class="number">0</span>准备工作,请求一台机器 <span class="number">1585323284818</span></span><br><span class="line">工人<span class="number">4</span>准备工作,请求一台机器 <span class="number">1585323284818</span></span><br><span class="line">工人<span class="number">3</span>准备工作,请求一台机器 <span class="number">1585323284818</span></span><br><span class="line">工人<span class="number">0</span>拿到机器,开始工作... <span class="number">1585323284818</span></span><br><span class="line">工人<span class="number">2</span>拿到机器,开始工作... <span class="number">1585323284818</span></span><br><span class="line">工人<span class="number">1</span>完成工作,释放机器! <span class="number">1585323286823</span></span><br><span class="line">工人<span class="number">4</span>拿到机器,开始工作... <span class="number">1585323286823</span></span><br><span class="line">工人<span class="number">0</span>完成工作,释放机器! <span class="number">1585323286823</span></span><br><span class="line">工人<span class="number">3</span>拿到机器,开始工作... <span class="number">1585323286823</span></span><br><span class="line">工人<span class="number">2</span>完成工作,释放机器! <span class="number">1585323286823</span></span><br><span class="line">工人<span class="number">3</span>完成工作,释放机器! <span class="number">1585323288829</span></span><br><span class="line">工人<span class="number">4</span>完成工作,释放机器! <span class="number">1585323288829</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><h4 id="1-使用多线程的目的是什么"><a href="#1-使用多线程的目的是什么" class="headerlink" title="1. 使用多线程的目的是什么?"></a>1. 使用多线程的目的是什么?</h4><p>充分利用cpu资源 , 并发进行多个任务</p><h4 id="2-单核CPU机器上适不适合多线程"><a href="#2-单核CPU机器上适不适合多线程" class="headerlink" title="2. 单核CPU机器上适不适合多线程?"></a>2. 单核CPU机器上适不适合多线程?</h4><p>适合 , 如果是单核CPU , 在线程中也可能需要等待IO , 此时CPU就空闲下来了 , 可以给其它线程使用。<br>但是一定要考虑其创建线程+销毁线程的时间是否超过了任务执行时间 , 考虑是否值得创建线程。</p><h4 id="3-线程什么时候会让出CPU"><a href="#3-线程什么时候会让出CPU" class="headerlink" title="3. 线程什么时候会让出CPU?"></a>3. 线程什么时候会让出CPU?</h4><p>(1) 阻塞时 wait await 等待IO<br>(2) sleep<br>(3) yield<br>(4) 线程结束</p><h4 id="4-线程是什么"><a href="#4-线程是什么" class="headerlink" title="4. 线程是什么?"></a>4. 线程是什么?</h4><p>一组代码执行流 , 完成一组代码的执行<br>这一组代码 , 我们可以称为一个任务</p><h4 id="5-CPU做的是什么工作"><a href="#5-CPU做的是什么工作" class="headerlink" title="5. CPU做的是什么工作?"></a>5. CPU做的是什么工作?</h4><p>执行代码</p><p><img src="http://free-cn-01.cdn.bilnn.com/ddimg/jfs/t1/93064/6/16337/4306/5e79a849Ed78a4550/4dddc413a9d716d2.png" alt="img"></p><h4 id="6-线程是不是越多越好"><a href="#6-线程是不是越多越好" class="headerlink" title="6. 线程是不是越多越好?"></a>6. 线程是不是越多越好?</h4><p>(1) 线程在Java中是一个对象 , 每一个Java线程都需要一个操作系统线程支持。线程创建、销毁都需要时间。如果<em>创建时间+销毁时间 &gt; 任务执行时间</em> , 就很<em>不合算*。<br>(2) Java对象占用堆内存 , 操作系统线程占用系统内存 , 根据JVM规范 , 一个线程默认最大栈大小为1M , 这个栈空间是需要从系统内存中分配的。<br>*线程过多 , 会消耗很多内存。</em><br>(3) 操作系统需要频繁切换线程上下文(所有线程都需要被执行) , 影响性能。</p><h4 id="7-如何正确使用多线程"><a href="#7-如何正确使用多线程" class="headerlink" title="7. 如何正确使用多线程?"></a>7. 如何正确使用多线程?</h4><p>多线程的目的: 充分利用CPU并发执行代码。<br>线程的本质: 将代码提交给CPU执行。<br>用合适数量的线程不断运送代码即可。<br>这些合适数量的线程就构成了一个池-线程池。</p><h4 id="8-synchronized和Lock的区别是什么"><a href="#8-synchronized和Lock的区别是什么" class="headerlink" title="8. synchronized和Lock的区别是什么?"></a>8. synchronized和Lock的区别是什么?</h4><p>(1) synchronized是Java内置的关键字 , 是在JVM层面上的。而Lock是一个Java类。<br>(2) synchronized无法判断是否获取锁的状态。Lock可以判断是否获取到锁。<br>(3) synchronized在执行完后会自动释放锁。而Lock必须要手动释放锁 , 否则会出现死锁。<br>(4) synchronized的锁可重入、不可中断、非公平。Lock锁可重入、可判断、可设置是否公平。<br>(5) synchronized适合给少量代码加锁。Lock适合给大量代码加锁。</p><h4 id="7-wait-和sleep-的区别是什么"><a href="#7-wait-和sleep-的区别是什么" class="headerlink" title="7. wait()和sleep()的区别是什么?"></a>7. wait()和sleep()的区别是什么?</h4><table><thead><tr><th></th><th>wait()</th><th>sleep()</th></tr></thead><tbody><tr><td>同步</td><td>只能在同步上下文中调用wait方法 , 否则或抛出IllegalMonitorStateException异常</td><td>不需要再同步方法或同步代码块中使用</td></tr><tr><td>作用对象</td><td>wait方法定义在Object类中 , 作用与(锁)对象本身</td><td>sleep方法定义在java.lang.Thread中 , 作用于当前线程</td></tr><tr><td>释放锁资源</td><td>是 , 调用wait()方法后锁资源就被释放了</td><td>否 , 调用sleep()后仍然占有锁资源</td></tr><tr><td>唤醒条件</td><td>其它线程调用notify()或者notifyAll()方法</td><td>超时或者调用interrupt()方法体</td></tr><tr><td>方法属性</td><td>Object对象的实例方法</td><td>Thread类的静态方法</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是微服务，SpringBoot和SpringCloud的关系</title>
      <link href="/2020/07/22/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8CSpringBoot%E5%92%8CSpringCloud%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2020/07/22/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8CSpringBoot%E5%92%8CSpringCloud%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>就目前而言对于微服务业界没有一个统一的,标准的定义.但通常而言,微服务是一种架构模式或者说是一种架构风格,它提倡单一应用程序划分为一组小的服务,每个服务在其独立的自己的进程中,服务之间相互协调,互相配合,为用户提供最终价值.服务之间采用轻量级的通信机制互相沟通(基于Http的Restful API)每个服务都围绕着具体的业务进行构建,并且能够被独立的部署到生产环境,类生产环境进行构建,可以有一个非常轻量级的集中式管理来协调这些服务,可以使用不同的语言来编写服务,也可以使用不同的数据存储.</p><h2 id="微服务与微服务架构"><a href="#微服务与微服务架构" class="headerlink" title="微服务与微服务架构?"></a>微服务与微服务架构?</h2><ul><li>微服务强调的是服务的大小,关注的是点,是具体解决某一个问题/提供落地对象服务的一个服务应用,</li><li>狭义的看,可以看做Eclipse中的一个个微服务工程.</li><li>微服务架构为一种架构模式.他提倡将单一应用程序分成一组小的服务,服务之间互相协调,互相配合,为用户提供最终价值.</li><li>每个服务运行在其独立的进程中,服务于服务间采用轻量级的通信机制互相协作(通常是Http 的Restful API) 每一个服务</li><li>都围绕着具体业务进行构建,并且能够被独立的部署到生产环境,类生产环境中.另外,应当尽量避免统一的,集中式的服务管理机制,</li><li>对具体的一个服务而言,应根据业务上下文,选择合适的语言,工具对其进行构建.</li></ul><h2 id="SpringCloud-是什么"><a href="#SpringCloud-是什么" class="headerlink" title="SpringCloud 是什么?"></a>SpringCloud 是什么?</h2><ul><li>基于SpringBoot提供了一套为微服务(microservices)解决方案,包括服务注册与发现,</li><li>配置中心,全链路监控,服务网关,负载均衡,熔断器等组件,除了基于NetFlix的开营组件做 高度抽象之外,还有一些选型中立了的开源组件.</li><li>分布式微服务架构下的一站式解决方案,是各个微服务架构落地技术的结合体,俗称为微服务全家桶.</li></ul><h2 id="SpringBoot和SpringCloud的关系和区别"><a href="#SpringBoot和SpringCloud的关系和区别" class="headerlink" title="SpringBoot和SpringCloud的关系和区别"></a>SpringBoot和SpringCloud的关系和区别</h2><ol><li>SpringBoot专注于方便的开发单个个体微服务</li><li>SpringCloud是关注于全局的微服务协调治理框架,它将SpringBoot开发的一个个单体微服务整合并管理起来.为各个微服务之间提供配置管理,服务发现,断路器,路由,微代理,事件总线,决策竞选,分布式会话等集成服务.</li><li>SpringBoot可以离开SpringCloud单独使用,而SpringCloud离不开SpringBoot</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将maven源改为国内阿里云镜像</title>
      <link href="/2020/07/22/%E5%B0%86maven%E6%BA%90%E6%94%B9%E4%B8%BA%E5%9B%BD%E5%86%85%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F/"/>
      <url>/2020/07/22/%E5%B0%86maven%E6%BA%90%E6%94%B9%E4%B8%BA%E5%9B%BD%E5%86%85%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interactiveMode</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">usePluginRegistry</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">offline</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><hr><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM中各层作用及关系</title>
      <link href="/2020/07/22/SSM%E4%B8%AD%E5%90%84%E5%B1%82%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%85%B3%E7%B3%BB/"/>
      <url>/2020/07/22/SSM%E4%B8%AD%E5%90%84%E5%B1%82%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="持久层：DAO层（mapper层）（属于mybatis模块）"><a href="#持久层：DAO层（mapper层）（属于mybatis模块）" class="headerlink" title="持久层：DAO层（mapper层）（属于mybatis模块）"></a>持久层：DAO层（mapper层）（属于mybatis模块）</h3><ul><li>DAO层：主要负责与数据库进行交互设计，用来处理数据的持久化工作。</li><li>DAO层的设计首先是设计DAO的接口，也就是项目中看到的Dao包。</li><li>然后在Spring的xml配置文件中定义此接口的实现类，就可在其他模块中调用此接口来进行数据业务的处理，而不用关心接口的具体实现类是哪个类，这里往往用到的就是反射机制，DAO层的jdbc.properties数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。</li><li>有的项目Dao层，写成mapper，当成一个意思理解。</li></ul><h3 id="业务层：Service层（属于spring模块）"><a href="#业务层：Service层（属于spring模块）" class="headerlink" title="业务层：Service层（属于spring模块）"></a>业务层：Service层（属于spring模块）</h3><ul><li><p>Service层：主要负责业务模块的逻辑应用设计。也就是项目中看到的Service包。</p></li><li><p>Service层的设计首先是设计接口，再设计其实现的类。也就是项目中看到的service+impl包。</p></li><li><p>接着再在Spring的xml配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。</p></li><li><p>最后通过调用DAO层已定义的接口，去实现Service具体的实现类。</p></li><li><p>Service层的业务实现，具体要调用到已定义的DAO层的接口。</p></li></ul><h3 id="控制层-表现层：Controller层（Handler层）-（属于springMVC模块）"><a href="#控制层-表现层：Controller层（Handler层）-（属于springMVC模块）" class="headerlink" title="控制层/表现层：Controller层（Handler层） （属于springMVC模块）"></a>控制层/表现层：Controller层（Handler层） （属于springMVC模块）</h3><ul><li>Controller层：主要负责具体的业务模块流程控制，也就是看到的controller包。</li><li>Controller层通过要调用Service层的接口来控制业务流程，控制的配置也同样是在Spring的xml配置文件里面，针对具体的业务流程，会有不同的控制器。</li></ul><h3 id="View层-（属于springMVC模块）"><a href="#View层-（属于springMVC模块）" class="headerlink" title="View层 （属于springMVC模块）"></a>View层 （属于springMVC模块）</h3><ul><li>负责前台jsp页面的展示，此层需要与Controller层结合起来开发。</li><li>Jsp发送请求，controller接收请求，处理，返回，jsp回显数据。</li></ul><h3 id="各层之间的联系"><a href="#各层之间的联系" class="headerlink" title="各层之间的联系"></a>各层之间的联系</h3><ul><li>DAO层，Service层这两个层次可以单独开发，互相的耦合度很低。</li><li>Controller，View层耦合度比较高，因而要结合在一起开发。也可以听当做两层来开发，这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，项目会显得清晰简单。</li><li>值得注意的是，Service逻辑层设计：Service层是建立在DAO层之上的，在Controller层之下。因而Service层应该既调用DAO层的接口，又提供接口给Controller层的类来进行调用，它处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。</li></ul><h3 id="SSM框架实现一个web程序主要使用到如下三个技术："><a href="#SSM框架实现一个web程序主要使用到如下三个技术：" class="headerlink" title="SSM框架实现一个web程序主要使用到如下三个技术："></a>SSM框架实现一个web程序主要使用到如下三个技术：</h3><ul><li>Spring：用到注解和自动装配，就是Spring的两个精髓IOC(反向控制)和 AOP(面向切面编程)。</li><li>SpringMVC：用到了MVC模型，将流程控制代码放到Controller层处理，将业务逻辑代码放到Service层处理。</li><li>Mybatis：用到了与数据库打交道的层面，dao（mapper）层，放在所有的逻辑之后，处理与数据库的CRUD相关的操作。</li></ul><h3 id="开发项目的时候，需要完成一个功能模块"><a href="#开发项目的时候，需要完成一个功能模块" class="headerlink" title="开发项目的时候，需要完成一个功能模块"></a>开发项目的时候，需要完成一个功能模块</h3><ul><li>先写实体类entity，定义对象的属性，（可以参照数据库中表的字段来设置，数据库的设计应该在所有编码开始之前）。</li><li>写Mapper.xml（Mybatis），其中定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</li><li>写Mapper.java/Dao.java，将Mapper.xml中的操作按照id映射成Java函数。实际上就是Dao接口，二者选一即可。</li><li>写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。</li><li>写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。</li><li>写JSP页面调用，请求哪些参数，需要获取什么数据。</li></ul><h3 id="面向对象——三层架构（表现层、业务层、持久层）"><a href="#面向对象——三层架构（表现层、业务层、持久层）" class="headerlink" title="面向对象——三层架构（表现层、业务层、持久层）"></a>面向对象——三层架构（表现层、业务层、持久层）</h3><p>三层架构：即表现层、业务层、持久层。</p><ul><li>持久层：采用DAO模式，建立实体类和数据库表映射（ORM映射）。也就是哪个类对应哪个表，哪个属性对应哪个列。持久层的目的就是，完成对象数据和关系数据的转换。</li><li>业务层：采用事务脚本模式。将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作，即保证同时成功或同时失败。避免部分成功部分失败引起的数据混乱操作。</li><li>表现层：采用MVC模式。<br>M称为模型，也就是实体类。用于数据的封装和数据的传输。<br>V为视图，也就是GUI组件，用于数据的展示。<br>C为控制，也就是事件，用于流程的控制</li><li>业务层接口的设计原则：一个实体类一个接口，一次提交一个业务方法。业务方法的参数自表现层。</li><li>持久层接口的设计原则：一个实体类一个接口，一次数据库操作一个持久方法。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> sring </tag>
            
            <tag> springmvc </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础学习</title>
      <link href="/2020/07/22/Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/07/22/Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis基础学习"><a href="#Redis基础学习" class="headerlink" title="Redis基础学习"></a>Redis基础学习</h3><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><ol><li><h6 id="概念-Redis是一款高性能的NoSQL系列的非关系型数据库"><a href="#概念-Redis是一款高性能的NoSQL系列的非关系型数据库" class="headerlink" title="概念: Redis是一款高性能的NoSQL系列的非关系型数据库"></a>概念: Redis是一款高性能的NoSQL系列的非关系型数据库</h6></li><li><h6 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作:"></a>命令操作:</h6><ol><li><p>Redis的数据结构:</p><ul><li><p>Redis存储的是: key-value格式的数据，其中key都是字符串，value有5种不同的数据结构</p></li><li><p>value的数据结构:</p><ol><li><p>字符串类型: String</p></li><li><p>哈希类型: hash(Map类型)</p></li><li><p>列表类型: list(Linkedlist)</p></li><li><p>集合类型: set</p></li><li><p>有序列表类型: sortedset</p></li></ol></li></ul></li><li><p>字符串类型 string</p><ol><li><p>存储: set key value</p></li><li><p>获取: get key</p></li><li><p>删除: del key</p><a id="more"></a></li></ol></li><li><p>哈希类型 hash</p><ol><li><p>存储: hset key field value</p></li><li><p>获取: hget key field</p></li><li><p>删除: hdel key field</p></li><li><p>获取hash中的所有键和值: hgetall key</p></li></ol></li><li><p>列表类型 list</p><ol><li><p>存储:</p><ul><li><p>lpush key value: 从左添加</p></li><li><p>rpush key value: 从右添加</p></li></ul></li><li><p>获取:</p><ul><li>lrange key start end: 范围获取(0 -1代表获取全部)</li></ul></li><li><p>删除:</p><ul><li><p>lpop key: 删除列表最左边的元素，并返回</p></li><li><p>rpop key: 删除列表最右边的元素，并返回</p></li></ul></li></ol></li><li><p>集合类型 set: 不允许重复元素(且无序)</p><ol><li><p>存储: sadd key value value1 value2 ….</p></li><li><p>获取: smembers key: 获取set集合中的所有元素</p></li><li><p>删除: srem key value: 删除set集合中的某个元素</p></li></ol></li><li><p>有序集合类型 sortedset: 不允许有重复元素，不同的是每个元素会有一个double类型的分数(权重)，按照此分数进行排序</p><ol><li><p>存储: zadd key score value</p></li><li><p>获取: zrange key start end</p></li><li><p>删除: zrem key value</p></li></ol></li><li><p>通用命令</p><ol><li><p>keys * : 查询所有的键</p></li><li><p>type key : 获取键对应的value的类型</p></li><li><p>del key: 删除指定的key value</p></li></ol></li></ol></li><li><h6 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h6><ol><li><p>Redis是一个内存数据库，当Redis服务器或电脑重启，数据会丢失，我们可以将Redis内存中的数据持久化保存到硬盘文件中</p></li><li><p>Redis持久化机制</p><ol><li><p>RDB: 默认方式，不需要进行配置，默认使用</p><ul><li>在一定间隔事件中，检测key的变化情况，然后持久化数据</li></ul><ol><li><p>编辑redis.windows.conf文件</p><ul><li><p>save 900 1(15分钟有一个key变化就持久化)</p></li><li><p>save 300 10</p></li><li><p>save 60 10000</p></li></ul></li><li><p>重新启动redis服务器并指定conf</p><ul><li>cmd启动服务器: redis-server.exe redis.windows.conf</li></ul></li></ol></li><li><p>AOF: 日志记录的方法，可以记录每一条命令的操作，然后持久化操作(不推荐)</p><ul><li>编辑redis.windows.conf</li></ul></li></ol><ul><li>appendonly no(关闭aof) –&gt; appendonly yes<ul><li>appendfsync always: 每一次操作都进行持久化<ul><li>appendfsync everysec: 每隔一秒都进行一次持久化</li></ul></li><li>appendfsync no : 不进行持久化</li></ul></li></ul></li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 使用（ssh key创建和github使用）</title>
      <link href="/2020/07/18/git-%E4%BD%BF%E7%94%A8%EF%BC%88ssh-key%E5%88%9B%E5%BB%BA%E5%92%8Cgithub%E4%BD%BF%E7%94%A8%EF%BC%89/"/>
      <url>/2020/07/18/git-%E4%BD%BF%E7%94%A8%EF%BC%88ssh-key%E5%88%9B%E5%BB%BA%E5%92%8Cgithub%E4%BD%BF%E7%94%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="ssh用于验证，https-github-com-需要，https-www-cloudcontrol-com-onboarding-ssh也需要。"><a href="#ssh用于验证，https-github-com-需要，https-www-cloudcontrol-com-onboarding-ssh也需要。" class="headerlink" title="ssh用于验证，https://github.com/ 需要，https://www.cloudcontrol.com/onboarding/ssh也需要。"></a>ssh用于验证，<a href="https://github.com/settings/ssh" target="_blank" rel="noopener">https://github.com/</a> 需要，<a href="https://www.cloudcontrol.com/onboarding/ssh也需要。" target="_blank" rel="noopener">https://www.cloudcontrol.com/onboarding/ssh也需要。</a></h4><h4 id="git使用记录"><a href="#git使用记录" class="headerlink" title="git使用记录"></a>git使用记录</h4><p>git是分布式的代码管理工具，远程的代码管理是基于ssh的，所以要使用远程的git则需要ssh的配置。</p><p>github的ssh配置如下：</p><h5 id="一-、设置git的user-name和email："><a href="#一-、设置git的user-name和email：" class="headerlink" title="一 、设置git的user name和email："></a>一 、设置git的user name和email：</h5><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name "xuhaiyan"</span><br><span class="line">$ git config --global user.email "haiyan.xu.vip@gmail.com"</span><br></pre></td></tr></tbody></table></figure><h5 id="二、生成SSH密钥过程："><a href="#二、生成SSH密钥过程：" class="headerlink" title="二、生成SSH密钥过程："></a>二、生成SSH密钥过程：</h5><p>1.查看是否已经有了ssh密钥：cd ~/.ssh<br>如果没有密钥则不会有此文件夹，有则备份删除<br>2.生存密钥：</p><blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C “haiyan.xu.vip@gmail.com”</span><br><span class="line">按3个回车，密码为空。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Your identification has been saved in /home/tekkub/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/tekkub/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">………………</span><br></pre></td></tr></tbody></table></figure></blockquote><p>最后得到了两个文件：id_rsa和id_rsa.pub</p><p>3.添加密钥到ssh：ssh-add 文件名</p><p>需要之前输入密码。<br>4.在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。</p><p>打开<a href="https://github.com/settings/ssh" target="_blank" rel="noopener">https://github.com/</a> ，登陆xuhaiyan825，然后添加ssh。</p><p>5.测试：ssh <a href="mailto:git@github.com">git@github.com</a></p><blockquote><p>The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.<br>RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘github.com,207.97.227.239′ (RSA) to the list of known hosts.<br>ERROR: Hi tekkub! You’ve successfully authenticated, but GitHub does not provide shell access<br>Connection to github.com closed.</p></blockquote><h5 id="三、-开始使用github"><a href="#三、-开始使用github" class="headerlink" title="三、 开始使用github"></a>三、 开始使用github</h5><p>1.获取源码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:billyanyteen/github-services.git</span><br></pre></td></tr></tbody></table></figure><p>2.这样你的机器上就有一个repo了。<br>3.git于svn所不同的是git是分布式的，没有服务器概念。所有的人的机器上都有一个repo，每次提交都是给自己机器的repo<br>仓库初始化：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></tbody></table></figure><p>生成快照并存入项目索引：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></tbody></table></figure><p>文件,还有git rm,git mv等等…<br>项目索引提交：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></tbody></table></figure><p>4.协作编程：<br>将本地repo于远程的origin的repo合并，<br>推送本地更新到远程：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></tbody></table></figure><p>更新远程更新到本地：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></tbody></table></figure><p>补充：<br>添加远端repo：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add upstream git://github.com/pjhyett/github-services.git</span><br></pre></td></tr></tbody></table></figure><p>重命名远端repo：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git://github.com/pjhyett/github-services.git为“upstream”</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+github搭建一个属于自己的服务器</title>
      <link href="/2020/06/01/%E4%BD%BF%E7%94%A8Hexo+github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/06/01/%E4%BD%BF%E7%94%A8Hexo+github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h4><p>node -v #查看node版本</p><p>npm -v #查看npm版本</p><p>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org" target="_blank" rel="noopener">http://registry.npm.taobao.org</a> #安装淘宝的cnpm 管理器</p><p>cnpm -v #查看cnpm版本</p><p>cnpm install -g hexo-cli #安装hexo框架</p><p>hexo -v #查看hexo版本</p><p>mkdir blog #创建blog目录</p><p>cd blog #进入blog目录</p><p>sudo hexo init #生成博客 初始化博客</p><p>hexo s #启动本地博客服务</p><p><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> #本地访问地址</p><p>hexo n “我的第一篇文章” #创建新的文章</p><p>返回blog目录</p><p>hexo clean #清理</p><p>hexo g #生成</p><p>Github创建一个新的仓库 YourGithubName.github.io</p><p>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p><h4 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置_config.yml"></a>配置_config.yml</h4><p>Deployment</p><p>Docs: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a></p><p>deploy:</p><p>type: git</p><p>repo: <a href="https://github.com/YourGithubName/YourGithubName.github.io.git" target="_blank" rel="noopener">https://github.com/YourGithubName/YourGithubName.github.io.git</a></p><p>branch: master</p><p>hexo d #部署到Github仓库里</p><p><a href="https://YourGithubName.github.io/" target="_blank" rel="noopener">https://YourGithubName.github.io/</a> #访问这个地址可以查看博客</p><p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia #下载yilia主题到本地</p><p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p><p>hexo c #清理一下</p><p>hexo g #生成</p><p>hexo d #部署到远程Github仓库</p><p>视频链接：<a href="https://www.bilibili.com/video/BV1Yb411a7ty?t=1486" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411a7ty?t=1486</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="/2020/06/01/hello%20world/"/>
      <url>/2020/06/01/hello%20world/</url>
      
        <content type="html"><![CDATA[<p>记录第一条博客</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> hello world </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
