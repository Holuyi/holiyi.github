{"meta":{"title":"Holuyi's Blog","subtitle":"","description":"","author":"Holuyi","url":"https://holuyi.github.io","root":"/"},"pages":[{"title":"404","date":"2020-07-21T17:15:46.000Z","updated":"2020-07-21T17:16:29.964Z","comments":true,"path":"404.html","permalink":"https://holuyi.github.io/404.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-07-21T17:06:49.000Z","updated":"2020-07-21T17:07:14.482Z","comments":true,"path":"contact/index.html","permalink":"https://holuyi.github.io/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-07-21T17:05:03.000Z","updated":"2020-07-21T17:05:34.349Z","comments":true,"path":"categories/index.html","permalink":"https://holuyi.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-07-21T17:05:43.000Z","updated":"2020-07-21T17:06:12.663Z","comments":true,"path":"tags/index.html","permalink":"https://holuyi.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"将maven源改为国内阿里云镜像","slug":"将maven源改为国内阿里云镜像","date":"2020-07-21T13:25:23.029Z","updated":"2020-07-21T13:25:23.197Z","comments":true,"path":"2020/07/21/将maven源改为国内阿里云镜像/","link":"","permalink":"https://holuyi.github.io/2020/07/21/%E5%B0%86maven%E6%BA%90%E6%94%B9%E4%B8%BA%E5%9B%BD%E5%86%85%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F/","excerpt":"","text":"1 12345678910111213141516171819202122&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;localRepository/&gt; &lt;interactiveMode/&gt; &lt;usePluginRegistry/&gt; &lt;offline/&gt; &lt;pluginGroups/&gt; &lt;servers/&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public &lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;proxies/&gt; &lt;profiles/&gt; &lt;activeProfiles/&gt;&lt;/settings&gt; 2 12345678910111213&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public &lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Redis基础学习","slug":"Redis基础学习","date":"2020-07-21T13:25:15.163Z","updated":"2020-07-21T16:15:04.127Z","comments":true,"path":"2020/07/21/Redis基础学习/","link":"","permalink":"https://holuyi.github.io/2020/07/21/Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"Redis基础学习Redis 概念: Redis是一款高性能的NoSQL系列的非关系型数据库 命令操作: Redis的数据结构: Redis存储的是: key-value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构: 字符串类型: String 哈希类型: hash(Map类型) 列表类型: list(Linkedlist) 集合类型: set 有序列表类型: sortedset 字符串类型 string 存储: set key value 获取: get key 删除: del key","text":"Redis基础学习Redis 概念: Redis是一款高性能的NoSQL系列的非关系型数据库 命令操作: Redis的数据结构: Redis存储的是: key-value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构: 字符串类型: String 哈希类型: hash(Map类型) 列表类型: list(Linkedlist) 集合类型: set 有序列表类型: sortedset 字符串类型 string 存储: set key value 获取: get key 删除: del key 哈希类型 hash 存储: hset key field value 获取: hget key field 删除: hdel key field 获取hash中的所有键和值: hgetall key 列表类型 list 存储: lpush key value: 从左添加 rpush key value: 从右添加 获取: lrange key start end: 范围获取(0 -1代表获取全部) 删除: lpop key: 删除列表最左边的元素，并返回 rpop key: 删除列表最右边的元素，并返回 集合类型 set: 不允许重复元素(且无序) 存储: sadd key value value1 value2 …. 获取: smembers key: 获取set集合中的所有元素 删除: srem key value: 删除set集合中的某个元素 有序集合类型 sortedset: 不允许有重复元素，不同的是每个元素会有一个double类型的分数(权重)，按照此分数进行排序 存储: zadd key score value 获取: zrange key start end 删除: zrem key value 通用命令 keys * : 查询所有的键 type key : 获取键对应的value的类型 del key: 删除指定的key value 持久化 Redis是一个内存数据库，当Redis服务器或电脑重启，数据会丢失，我们可以将Redis内存中的数据持久化保存到硬盘文件中 Redis持久化机制 RDB: 默认方式，不需要进行配置，默认使用 在一定间隔事件中，检测key的变化情况，然后持久化数据 编辑redis.windows.conf文件 save 900 1(15分钟有一个key变化就持久化) save 300 10 save 60 10000 重新启动redis服务器并指定conf cmd启动服务器: redis-server.exe redis.windows.conf AOF: 日志记录的方法，可以记录每一条命令的操作，然后持久化操作(不推荐) 编辑redis.windows.conf appendonly no(关闭aof) –&gt; appendonly yes appendfsync always: 每一次操作都进行持久化 appendfsync everysec: 每隔一秒都进行一次持久化 appendfsync no : 不进行持久化 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"git 使用（ssh key创建和github使用）","slug":"git 使用（ssh key创建和github使用）","date":"2020-07-21T13:25:09.459Z","updated":"2020-07-21T16:11:05.525Z","comments":true,"path":"2020/07/21/git 使用（ssh key创建和github使用）/","link":"","permalink":"https://holuyi.github.io/2020/07/21/git%20%E4%BD%BF%E7%94%A8%EF%BC%88ssh%20key%E5%88%9B%E5%BB%BA%E5%92%8Cgithub%E4%BD%BF%E7%94%A8%EF%BC%89/","excerpt":"ssh用于验证，https://github.com/ 需要，https://www.cloudcontrol.com/onboarding/ssh也需要。git使用记录git是分布式的代码管理工具，远程的代码管理是基于ssh的，所以要使用远程的git则需要ssh的配置。 github的ssh配置如下： 一 、 设置git的user name和email： 12$ git config --global user.name \"xuhaiyan\"$ git config --global user.email \"haiyan.xu.vip@gmail.com\" 二、生成SSH密钥过程：1.查看是否已经有了ssh密钥：cd ~/.ssh如果没有密钥则不会有此文件夹，有则备份删除2.生存密钥： 123456789$ ssh-keygen -t rsa -C “haiyan.xu.vip@gmail.com”按3个回车，密码为空。Your identification has been saved in /home/tekkub/.ssh/id_rsa.Your public key has been saved in /home/tekkub/.ssh/id_rsa.pub.The key fingerprint is:……………… 最后得到了两个文件：id_rsa和id_rsa.pub","text":"ssh用于验证，https://github.com/ 需要，https://www.cloudcontrol.com/onboarding/ssh也需要。git使用记录git是分布式的代码管理工具，远程的代码管理是基于ssh的，所以要使用远程的git则需要ssh的配置。 github的ssh配置如下： 一 、 设置git的user name和email： 12$ git config --global user.name \"xuhaiyan\"$ git config --global user.email \"haiyan.xu.vip@gmail.com\" 二、生成SSH密钥过程：1.查看是否已经有了ssh密钥：cd ~/.ssh如果没有密钥则不会有此文件夹，有则备份删除2.生存密钥： 123456789$ ssh-keygen -t rsa -C “haiyan.xu.vip@gmail.com”按3个回车，密码为空。Your identification has been saved in /home/tekkub/.ssh/id_rsa.Your public key has been saved in /home/tekkub/.ssh/id_rsa.pub.The key fingerprint is:……………… 最后得到了两个文件：id_rsa和id_rsa.pub 3.添加密钥到ssh：ssh-add 文件名需要之前输入密码。4.在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。 打开https://github.com/ ，登陆xuhaiyan825，然后添加ssh。 5.测试：ssh git@github.com The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘github.com,207.97.227.239′ (RSA) to the list of known hosts.ERROR: Hi tekkub! You’ve successfully authenticated, but GitHub does not provide shell accessConnection to github.com closed. 三、 开始使用github1.获取源码： 1$ git clone git@github.com:billyanyteen/github-services.git 2.这样你的机器上就有一个repo了。3.git于svn所不同的是git是分布式的，没有服务器概念。所有的人的机器上都有一个repo，每次提交都是给自己机器的repo仓库初始化： 1git init 生成快照并存入项目索引： 1git add 文件,还有git rm,git mv等等…项目索引提交： 1git commit 4.协作编程：将本地repo于远程的origin的repo合并，推送本地更新到远程： 1git push origin master 更新远程更新到本地： 1git pull origin master 补充：添加远端repo： 1$ git remote add upstream git://github.com/pjhyett/github-services.git 重命名远端repo： 1$ git://github.com/pjhyett/github-services.git为“upstream” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"什么是微服务，SpringBoot和SpringCloud的关系","slug":"什么是微服务，SpringBoot和SpringCloud的关系","date":"2020-07-21T07:56:13.569Z","updated":"2020-07-21T16:16:00.647Z","comments":true,"path":"2020/07/21/什么是微服务，SpringBoot和SpringCloud的关系/","link":"","permalink":"https://holuyi.github.io/2020/07/21/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8CSpringBoot%E5%92%8CSpringCloud%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"什么是微服务就目前而言对于微服务业界没有一个统一的,标准的定义.但通常而言,微服务是一种架构模式或者说是一种架构风格,它提倡单一应用程序划分为一组小的服务,每个服务在其独立的自己的进程中,服务之间相互协调,互相配合,为用户提供最终价值.服务之间采用轻量级的通信机制互相沟通(基于Http的Restful API)每个服务都围绕着具体的业务进行构建,并且能够被独立的部署到生产环境,类生产环境进行构建,可以有一个非常轻量级的集中式管理来协调这些服务,可以使用不同的语言来编写服务,也可以使用不同的数据存储.","text":"什么是微服务就目前而言对于微服务业界没有一个统一的,标准的定义.但通常而言,微服务是一种架构模式或者说是一种架构风格,它提倡单一应用程序划分为一组小的服务,每个服务在其独立的自己的进程中,服务之间相互协调,互相配合,为用户提供最终价值.服务之间采用轻量级的通信机制互相沟通(基于Http的Restful API)每个服务都围绕着具体的业务进行构建,并且能够被独立的部署到生产环境,类生产环境进行构建,可以有一个非常轻量级的集中式管理来协调这些服务,可以使用不同的语言来编写服务,也可以使用不同的数据存储. 微服务与微服务架构? 微服务强调的是服务的大小,关注的是点,是具体解决某一个问题/提供落地对象服务的一个服务应用, 狭义的看,可以看做Eclipse中的一个个微服务工程. 微服务架构为一种架构模式.他提倡将单一应用程序分成一组小的服务,服务之间互相协调,互相配合,为用户提供最终价值. 每个服务运行在其独立的进程中,服务于服务间采用轻量级的通信机制互相协作(通常是Http 的Restful API) 每一个服务 都围绕着具体业务进行构建,并且能够被独立的部署到生产环境,类生产环境中.另外,应当尽量避免统一的,集中式的服务管理机制, 对具体的一个服务而言,应根据业务上下文,选择合适的语言,工具对其进行构建. SpringCloud 是什么? 基于SpringBoot提供了一套为微服务(microservices)解决方案,包括服务注册与发现, 配置中心,全链路监控,服务网关,负载均衡,熔断器等组件,除了基于NetFlix的开营组件做 高度抽象之外,还有一些选型中立了的开源组件. 分布式微服务架构下的一站式解决方案,是各个微服务架构落地技术的结合体,俗称为微服务全家桶. SpringBoot和SpringCloud的关系和区别 SpringBoot专注于方便的开发单个个体微服务 SpringCloud是关注于全局的微服务协调治理框架,它将SpringBoot开发的一个个单体微服务整合并管理起来.为各个微服务之间提供配置管理,服务发现,断路器,路由,微代理,事件总线,决策竞选,分布式会话等集成服务. SpringBoot可以离开SpringCloud单独使用,而SpringCloud离不开SpringBoot document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"SSM中各层作用及关系","slug":"SSM中各层作用及关系","date":"2020-07-21T07:56:13.553Z","updated":"2020-07-21T16:15:47.702Z","comments":true,"path":"2020/07/21/SSM中各层作用及关系/","link":"","permalink":"https://holuyi.github.io/2020/07/21/SSM%E4%B8%AD%E5%90%84%E5%B1%82%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%85%B3%E7%B3%BB/","excerpt":"持久层：DAO层（mapper层）（属于mybatis模块） DAO层：主要负责与数据库进行交互设计，用来处理数据的持久化工作。 DAO层的设计首先是设计DAO的接口，也就是项目中看到的Dao包。 然后在Spring的xml配置文件中定义此接口的实现类，就可在其他模块中调用此接口来进行数据业务的处理，而不用关心接口的具体实现类是哪个类，这里往往用到的就是反射机制，DAO层的jdbc.properties数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。 有的项目Dao层，写成mapper，当成一个意思理解。 业务层：Service层（属于spring模块） Service层：主要负责业务模块的逻辑应用设计。也就是项目中看到的Service包。 Service层的设计首先是设计接口，再设计其实现的类。也就是项目中看到的service+impl包。 接着再在Spring的xml配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。 最后通过调用DAO层已定义的接口，去实现Service具体的实现类。 Service层的业务实现，具体要调用到已定义的DAO层的接口。","text":"持久层：DAO层（mapper层）（属于mybatis模块） DAO层：主要负责与数据库进行交互设计，用来处理数据的持久化工作。 DAO层的设计首先是设计DAO的接口，也就是项目中看到的Dao包。 然后在Spring的xml配置文件中定义此接口的实现类，就可在其他模块中调用此接口来进行数据业务的处理，而不用关心接口的具体实现类是哪个类，这里往往用到的就是反射机制，DAO层的jdbc.properties数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。 有的项目Dao层，写成mapper，当成一个意思理解。 业务层：Service层（属于spring模块） Service层：主要负责业务模块的逻辑应用设计。也就是项目中看到的Service包。 Service层的设计首先是设计接口，再设计其实现的类。也就是项目中看到的service+impl包。 接着再在Spring的xml配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。 最后通过调用DAO层已定义的接口，去实现Service具体的实现类。 Service层的业务实现，具体要调用到已定义的DAO层的接口。 控制层/表现层：Controller层（Handler层） （属于springMVC模块） Controller层：主要负责具体的业务模块流程控制，也就是看到的controller包。 Controller层通过要调用Service层的接口来控制业务流程，控制的配置也同样是在Spring的xml配置文件里面，针对具体的业务流程，会有不同的控制器。 View层 （属于springMVC模块） 负责前台jsp页面的展示，此层需要与Controller层结合起来开发。 Jsp发送请求，controller接收请求，处理，返回，jsp回显数据。 各层之间的联系 DAO层，Service层这两个层次可以单独开发，互相的耦合度很低。 Controller，View层耦合度比较高，因而要结合在一起开发。也可以听当做两层来开发，这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，项目会显得清晰简单。 值得注意的是，Service逻辑层设计：Service层是建立在DAO层之上的，在Controller层之下。因而Service层应该既调用DAO层的接口，又提供接口给Controller层的类来进行调用，它处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。 SSM框架实现一个web程序主要使用到如下三个技术： Spring：用到注解和自动装配，就是Spring的两个精髓IOC(反向控制)和 AOP(面向切面编程)。 SpringMVC：用到了MVC模型，将流程控制代码放到Controller层处理，将业务逻辑代码放到Service层处理。 Mybatis：用到了与数据库打交道的层面，dao（mapper）层，放在所有的逻辑之后，处理与数据库的CRUD相关的操作。 开发项目的时候，需要完成一个功能模块 先写实体类entity，定义对象的属性，（可以参照数据库中表的字段来设置，数据库的设计应该在所有编码开始之前）。 写Mapper.xml（Mybatis），其中定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。 写Mapper.java/Dao.java，将Mapper.xml中的操作按照id映射成Java函数。实际上就是Dao接口，二者选一即可。 写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。 写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。 写JSP页面调用，请求哪些参数，需要获取什么数据。 面向对象——三层架构（表现层、业务层、持久层）三层架构：即表现层、业务层、持久层。 持久层：采用DAO模式，建立实体类和数据库表映射（ORM映射）。也就是哪个类对应哪个表，哪个属性对应哪个列。持久层的目的就是，完成对象数据和关系数据的转换。 业务层：采用事务脚本模式。将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作，即保证同时成功或同时失败。避免部分成功部分失败引起的数据混乱操作。 表现层：采用MVC模式。M称为模型，也就是实体类。用于数据的封装和数据的传输。V为视图，也就是GUI组件，用于数据的展示。C为控制，也就是事件，用于流程的控制 业务层接口的设计原则：一个实体类一个接口，一次提交一个业务方法。业务方法的参数自表现层。 持久层接口的设计原则：一个实体类一个接口，一次数据库操作一个持久方法。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"使用Hexo+github搭建一个属于自己的服务器","slug":"使用Hexo+github搭建一个属于自己的服务器","date":"2020-07-21T05:09:27.341Z","updated":"2020-07-21T16:16:09.382Z","comments":true,"path":"2020/07/21/使用Hexo+github搭建一个属于自己的服务器/","link":"","permalink":"https://holuyi.github.io/2020/07/21/%E4%BD%BF%E7%94%A8Hexo+github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"#安装Nodejs node -v #查看node版本 npm -v #查看npm版本 npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器 cnpm -v #查看cnpm版本 cnpm install -g hexo-cli #安装hexo框架 hexo -v #查看hexo版本 mkdir blog #创建blog目录 cd blog #进入blog目录 sudo hexo init #生成博客 初始化博客 hexo s #启动本地博客服务 http://localhost:4000/ #本地访问地址 hexo n “我的第一篇文章” #创建新的文章 返回blog目录 hexo clean #清理 hexo g #生成 Github创建一个新的仓库 YourGithubName.github.io cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件","text":"#安装Nodejs node -v #查看node版本 npm -v #查看npm版本 npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器 cnpm -v #查看cnpm版本 cnpm install -g hexo-cli #安装hexo框架 hexo -v #查看hexo版本 mkdir blog #创建blog目录 cd blog #进入blog目录 sudo hexo init #生成博客 初始化博客 hexo s #启动本地博客服务 http://localhost:4000/ #本地访问地址 hexo n “我的第一篇文章” #创建新的文章 返回blog目录 hexo clean #清理 hexo g #生成 Github创建一个新的仓库 YourGithubName.github.io cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件 -— #配置_config.yml -—-Deployment Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/YourGithubName/YourGithubName.github.io.git branch: master -—- hexo d #部署到Github仓库里 https://YourGithubName.github.io/ #访问这个地址可以查看博客 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载yilia主题到本地 #修改hexo根目录下的 _config.yml 文件 ： theme: yilia hexo c #清理一下 hexo g #生成 hexo d #部署到远程Github仓库 视频链接：https://www.bilibili.com/video/BV1Yb411a7ty?t=1486 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-07-20T10:54:13.460Z","updated":"2020-07-20T10:54:13.460Z","comments":true,"path":"2020/07/20/hello-world/","link":"","permalink":"https://holuyi.github.io/2020/07/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}],"categories":[],"tags":[]}