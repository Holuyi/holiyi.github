{"meta":{"title":"Holuyi's Blog","subtitle":"","description":"","author":"Holuyi","url":"https://github.com/Holuyi/holuyi.github.io","root":"/"},"pages":[{"title":"404","date":"2020-07-21T17:15:46.000Z","updated":"2020-07-21T17:16:29.964Z","comments":true,"path":"404.html","permalink":"https://github.com/Holuyi/holuyi.github.io/404.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-07-21T17:06:49.000Z","updated":"2020-07-21T17:07:14.482Z","comments":true,"path":"contact/index.html","permalink":"https://github.com/Holuyi/holuyi.github.io/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-07-21T17:05:03.000Z","updated":"2020-07-21T17:05:34.349Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/Holuyi/holuyi.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-07-21T17:05:43.000Z","updated":"2020-07-21T17:06:12.663Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"ArrayList和HashMap的比较","slug":"ArrayList和HashMap的比较","date":"2020-07-24T13:00:31.000Z","updated":"2020-07-24T13:05:45.892Z","comments":true,"path":"2020/07/24/ArrayList和HashMap的比较/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/24/ArrayList%E5%92%8CHashMap%E7%9A%84%E6%AF%94%E8%BE%83/","excerpt":"","text":"ArrayList和HashMap是Java项目开发中经常用到的容器，下面来比较一下两者之间的区别！ 例子： ArrayList:ArrayList array = new ArrayList(); array.add(\"张三\"); array.add(\"李四\"); array.add(\"王五\"); System.out.println(\"ArrayList的元素个数为：\"+array.size()); //遍历方法一：通过迭代器Iterator进行遍历 Iterator iter = array.iterator(); while(iter.hasNext()){ String name = (String)iter.next(); System.out.println(name); } //遍历方法二：使用for循环遍历 for(int i=0;i&lt;array.size();i++){ System.out.println(array.get(i)); } HashMap:Ha shMap hashMap = new HashMap(); hashMap.put(\"name\", \"张三\"); hashMap.put(\"name1\", \"李四\"); hashMap.put(\"name2\", \"王五\"); System.out.println(\"HashMap的元素个数为：\"+hashMap.size()); //遍历方法一：hashMap.entrySet()方法，通过迭代器Iterator进行遍历 效率高，推荐使用 Iterator iter1 = hashMap.entrySet().iterator(); while(iter1.hasNext()){ Map.Entry name = (Map.Entry)iter1.next(); String nameKey = (String)name.getKey(); String nameValue = (String)name.getValue(); System.out.println(nameKey + \"'s name is \" + nameValue); } //遍历方法二：hashMap.keySet()方法，通过迭代器Iterator进行遍历 效率低，不推荐使用 Iterator iter2 = hashMap.keySet().iterator(); while (iter2.hasNext()) { Object key = iter.next(); Object val = hashMap.get(key); } //遍历方法三：foreach方法来遍历keyset，和第二种没有什么区别 Set keySet = hashMap.keySet(); for(Object key: keySet) { System.out.print(\"[key=\" + key + \",value=\" + hashMap.get(key) + \"] \"); } //遍历方法四：java8中新增方法forEach。 hashMap.forEach((key,value) -&gt; { System.out.print(\"[key=\" + key + \",value=\" + value + \"] \"); }); 相同点： 1）都是线程不安全，不同步 2）都可以储存null值 3）获取元素个数方法一样，都用size()方法获取 区别： 1）实现的接口 ArrayList实现了List接口（Collection（接口）-&gt;List（接口）-&gt;ArrayList（类）），底层使用的是数组；而HashMap现了Map接口（Map（接口）-&gt;HashMap（类）），底层使用的是Hash算法存储数据。 2）存储元素 ArrayList以数组的方式存储数据，里面的元素是有顺序，可以重复的；而HashMap将数据以键值对的方式存储，键的哈希码（hashCode）不可以相同，相同后面的值会将前面的值覆盖，值可以重复，里面的元素无序。 3）添加元素的方法 ArrayList用add(Object object)方法添加元素，而HashMap用put(Object key, Object value)添加元素。 4）默认的大小和扩容 在 Java 7 中，ArrayList的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。 ArrayList源码 /** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; HashMap源码 /** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 ArrayList扩容增量：原容量的0.5倍+1，如 ArrayList的容量为10，一次扩容后是容量为16； HashMap扩容增量：原容量的 1 倍，加载因子为0.75：即当 元素个数 超过 容量长度的0.75倍时，进行扩容，如 HashSet的容量为16，一次扩容后是容量为32 使用场景：如果需要快速随机访问元素，应该使用ArrayList。需要键值对形式的数据时，应该使用HashMap 补充内容：加载因子是表示Hash表中元素的填满的程度.若加载因子越大,填满的元素越多,好处是空间利用率高了,但冲突的机会加大了.反之,加载因子越小,填满的元素越少,好处是冲突的机会减小了,但空间浪费多了.冲突的机会越大,则查找的成本越高.反之,查找的成本越小.因而,查找时间就越小.因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的”时-空”矛盾的平衡与折衷.当元素个数超过 容量长度*加载因子的系数 时，会进行扩容。 原文链接 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"集合","slug":"集合","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"Java多线程（四）：集合类不安全和常用的辅助类","slug":"Java多线程（四）：集合类不安全和常用的辅助类","date":"2020-07-24T10:30:59.000Z","updated":"2020-07-24T12:46:03.937Z","comments":true,"path":"2020/07/24/Java多线程（四）：集合类不安全和常用的辅助类/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8D%E5%AE%89%E5%85%A8%E5%92%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB/","excerpt":"","text":"Java多线程(四)：集合类不安全和常用的辅助类本文主要内容：解决多线程操作集合类不安全问题、常用的辅助类 一、集合类不安全 ArrayList 当我们使用多线程操作同一个ArrayList时会产生以下问题：java.util.ConcurrentModificationException(并发修改异常) public class SafeArrayList { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 100 ; i++) { new Thread(() -&gt; { list.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(list); }, String.valueOf(i)).start(); } } } 为了解决上述问题，我们使用如下三种方式解决问题 public class SafeArrayList { public static void main(String[] args) { // 方式一：使用Vector(默认线程安全)替代ArrayList //List&lt;String&gt; list = new Vector&lt;&gt;(); // 方式二：使用Collections集合类产生一个线程安全的ArrayList //List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); // 方式三：使用JUC包下的CopyOnWriteArrayList产生一个线程安全的ArrayList // CopyOnWrite：写入时复制是计算机程序设计领域的一种优化策略 // CopyOnWriteArrayList底层使用Lock锁比Vector底层使用Synchronized效率要高 List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 1; i &lt;= 100 ; i++) { new Thread(() -&gt; { list.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(list); }, String.valueOf(i)).start(); } } } Set 当我们使用多线程操作同一个HashSet时会产生以下问题：java.util.ConcurrentModificationException(并发修改异常) public class SafeSet { public static void main(String[] args) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 1; i &lt;= 100 ; i++) { new Thread(() -&gt; { set.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(set); }, String.valueOf(i)).start(); } } } 为了解决上述问题，我们使用如下二种方式解决问题 public class SafeSet { public static void main(String[] args) { // 方式一：使用Collections集合类产生一个线程安全的HashSet // Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;()); // 方式二：使用JUC包下的CopyOnWriteArraySet产生一个线程安全的HashSet Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;(); for (int i = 1; i &lt;= 100 ; i++) { new Thread(() -&gt; { set.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(set); }, String.valueOf(i)).start(); } } } Map 当我们使用多线程操作同一个HashMap时会产生以下问题：java.util.ConcurrentModificationException(并发修改异常) public class SafeMap { public static void main(String[] args) { Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (int i = 1; i &lt;= 100 ; i++) { new Thread(() -&gt; { map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5)); }, String.valueOf(i)).start(); } } } 为了解决上述问题，我们使用如下二种方式解决问题 public class SafeMap { public static void main(String[] args) { // 方式一：使用Collections集合类产生一个线程安全的HashMap // Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); // 方式二：使用JUC包下的ConcurrentHashMap产生一个线程安全的HashMap Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); for (int i = 1; i &lt;= 100 ; i++) { new Thread(() -&gt; { map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5)); }, String.valueOf(i)).start(); } } } 二、Callable接口方式开启多线程 Callable接口方式开启多线程 public class CallableThread { public static void main(String[] args) throws ExecutionException, InterruptedException { // 通过RunnableFuture接口的实现类FutureTask来传参使用Callable方式产生的多线程 FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new MyThread()); new Thread(task).start(); // 通过FutureTask来获取Callable接口中方法的返回值 Integer result = task.get(); System.out.println(result); } } class MyThread implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { System.out.println(\"执行了call()\"); return 512; } } 使用Callable接口的一些细节问题： 使用Callable会有缓存：就是如果重复调用执行同一个Callable接口实现的线程，那么call()方法只会执行一次 FutureTask的get方法可能会产生阻塞问题 三、常用的辅助类 CountDownLatch：递减计数器 public class CountDownLatchTest { public static void main(String[] args) throws InterruptedException { // 需求：需要6个学生(线程)都离开再执行关门方法 CountDownLatch countDownLatch = new CountDownLatch(6); // 初始的默认数量 for (int i = 1; i &lt;= 6 ; i++) { new Thread(() -&gt; { System.out.println(Thread.currentThread().getName() + \"号学生离开了\"); countDownLatch.countDown(); }, String.valueOf(i)).start(); } countDownLatch.await(); //等待计数器归零，然后再向下执行 System.out.println(\"关门了..........\"); } } countDownLatch.countDown()：数量 - 1countDownLatch.await()：等待计数器归零，然后再向下执行 CyclicBarrier：递加计数器 public class CyclicBarrierTest { public static void main(String[] args) { // 需求：集齐7条龙珠(跑完7条线程)召唤神龙(执行最终线程：在CyclicBarrier声明最后线程) CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; { System.out.println(\"召唤神龙\"); }); for (int i = 1; i &lt;= 7 ; i++) { final int temp = i; new Thread(() -&gt; { System.out.println(\"第\" + temp +\"只龙珠被集齐\"); try { cyclicBarrier.await(); // await()方法可以让当前计数器数量+1，达到7即结束 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }).start(); } } } cyclicBarrier.await()：当前计数器数量+1，达到自定义值即结束 Semaphore：信号量，就是一组通行证 public class SemaphoreTest { public static void main(String[] args) { // 需求：有6辆车(6条线程)需要进去停车场(完成方法)，但一次最多进入3辆 Semaphore semaphore = new Semaphore(3); for (int i = 1; i &lt;= 6 ; i++) { new Thread(() -&gt; { try { semaphore.acquire(); //获取通行证 System.out.println(Thread.currentThread().getName() + \"进入了停车场\"); TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName() + \"离开了停车场\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); // 释放通行证 } }, String.valueOf(i)).start(); } } } semaphore.acquire()：获得，假设如果已经满了，等待，等待被释放为止 semaphore.release()：释放，会将当前的信号量 - 1，然后唤醒等待的线程 作用：多个共享资源互斥的使用，并发限流，控制最大的线程数 转载链接Java多线程(四) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"线程","slug":"线程","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java多线程（三）","slug":"Java多线程（三）Synchronized与Lock的使用","date":"2020-07-24T10:14:33.000Z","updated":"2020-07-24T10:26:45.995Z","comments":true,"path":"2020/07/24/Java多线程（三）Synchronized与Lock的使用/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89Synchronized%E4%B8%8ELock%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Java多线程(三)：Synchronized与Lock的使用本文主要内容：Lock锁解决卖票问题、Lock版的生产者与消费者和Synchronized与Lock区别 Lock锁解决卖票问题1.Synchronized版 public class SaleTicket_Synchronized { public static void main(String[] args) { Ticket_Synchronized ticket_synchronized = new Ticket_Synchronized(); new Thread(() -&gt; { for (int i = 0; i &lt;= 100; i++) ticket_synchronized.sale(); }, \"A\").start(); new Thread(() -&gt; { for (int i = 0; i &lt;= 100; i++) ticket_synchronized.sale(); }, \"B\").start(); new Thread(() -&gt; { for (int i = 0; i &lt;= 100; i++) ticket_synchronized.sale(); }, \"C\").start(); } } // 资源类，通过多线程操作同一个资源类 class Ticket_Synchronized{ private int ticket = 100; public synchronized void sale(){ if (ticket &gt; 0){ System.out.println(Thread.currentThread().getName() + \"卖出出了第\" + ticket-- + \"张票，剩余\" + ticket + \"张\"); } } } 2.Lock版 public class SaleTicket_Lock { public static void main(String[] args) { Ticket_Lock ticket_lock = new Ticket_Lock(); new Thread(() -&gt; { for (int i = 0; i &lt;= 100; i++) ticket_lock.sale(); }, \"A\").start(); new Thread(() -&gt; { for (int i = 0; i &lt;= 100; i++) ticket_lock.sale(); }, \"B\").start(); new Thread(() -&gt; { for (int i = 0; i &lt;= 100; i++) ticket_lock.sale(); }, \"C\").start(); } } // 资源类，通过多线程操作同一个资源类 class Ticket_Lock{ private int ticket = 100; Lock lock = new ReentrantLock(); public void sale(){ // 加锁 lock.lock(); try { if (ticket &gt; 0){ System.out.println(Thread.currentThread().getName() + \"卖出出了第\" + ticket-- + \"张票，剩余\" + ticket + \"张\"); } } catch (Exception e) { e.printStackTrace(); } finally { // 解锁 lock.unlock(); } } } Lock版的生产者与消费者(线程间的通信问题)1.此案例为：交替打印10次数字+1与数字-1 2.Synchronized版 public class ProducerAndConsumer_Synchronized { public static void main(String[] args) { Data_Synchronized data_synchronized = new Data_Synchronized(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { try { data_synchronized.increment(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"A\").start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { try { data_synchronized.decrement(); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"B\").start(); } } class Data_Synchronized{ private int data = 0; // data + 1 方法 public synchronized void increment() throws InterruptedException { while (data != 0) { //等待 this.wait(); } //执行 data += 1; System.out.println(Thread.currentThread().getName() + \"--&gt;\" + data); //通知其它线程我已经完成+1 this.notifyAll(); } // data - 1 方法 public synchronized void decrement() throws InterruptedException { while (data == 0) { //等待 this.wait(); } //执行 data -= 1; System.out.println(Thread.currentThread().getName() + \"--&gt;\" + data); //通知其它线程我已经完成-1 this.notifyAll(); } } 3.Lock版 public class ProducerAndConsumer_Lock { public static void main(String[] args) { Data_Lock data_lock = new Data_Lock(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { data_lock.increment(); } }, \"A\").start(); new Thread(() -&gt; { for (int i = 0; i &lt; 10; i++) { data_lock.decrement(); } }, \"B\").start(); } } class Data_Lock{ private int data = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); // data + 1 方法 public void increment(){ lock.lock(); try { while (data != 0) { //等待 condition.await(); } //执行 data += 1; System.out.println(Thread.currentThread().getName() + \"--&gt;\" + data); //通知其它线程我已经完成+1 condition.signalAll(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } // data - 1 方法 public void decrement(){ lock.lock(); try { while (data == 0) { //等待 condition.await(); } //执行 data -= 1; System.out.println(Thread.currentThread().getName() + \"--&gt;\" + data); //通知其它线程我已经完成+1 condition.signalAll(); } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } } Synchronized与Lock区别1、Synchronized是Java关键字，Lock是一个Java类2、Synchronized无法判断锁的状态，Lock可以判断是否获取到了锁3、Synchronized会自动释放锁，Lock必须要手动释放(否则造成死锁问题)4、Synchronized中线程1如果获得锁并阻塞，线程2会一直等待，Lock锁就不一定会等待下去5、Synchronized是可重入锁，不可以中断，非公平，Lock是可重入锁，不可以中断，非公平(但可以使用new ReentrantLock(true)的方式改变公平)6、Synchronized适合少量代码同步问题，Lock锁适合大量的同步代码 转载链接Java多线程（三） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"线程","slug":"线程","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java多线程（二）","slug":"Java多线程（二）","date":"2020-07-24T10:14:33.000Z","updated":"2020-07-24T10:27:06.086Z","comments":true,"path":"2020/07/24/Java多线程（二）/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"Java多线程(二)本文主要内容：线程安全、线程池、线程间通信 线程安全问题引入: 多个窗口同时出售100张票 class MyThread implements Runnable { private int ticket = 100; @Override public void run() { while (true) { if (ticket &gt; 0) { try { sleep(100); System.out.println(Thread.currentThread().getName() + \"卖出一张票，还剩： \" + ticket); } catch (InterruptedException e) { e.printStackTrace(); } ticket--; } else break; } } } public class Test1 { public static void main(String[] args) { MyThread thread = new MyThread(); new Thread(thread, \"窗口1\").start(); new Thread(thread, \"窗口2\").start(); new Thread(thread, \"窗口3\").start(); } } 会产生下面问题: * 解决方法一: 同步代码块 synchronized(同步监视器){ //需要被同步的代码 } 注意: 1.操作共享数据的代码，即为需要被同步的代码 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据 3.同步监视器：俗称：锁，任何一个类的对象，都可以充当锁 要求：多个线程必须要公用同一把锁 class MyThread implements Runnable { private int ticket = 100; @Override public void run() { while (true) { synchronized (this) { //this相当于MyThread类的对象thread if (ticket &gt; 0) { try { sleep(100); System.out.println(Thread.currentThread().getName() + \"卖出一张票，还剩： \" + ticket); } catch (InterruptedException e) { e.printStackTrace(); } ticket--; } else break; } } } } public class Test1 { public static void main(String[] args) { MyThread thread = new MyThread(); new Thread(thread, \"窗口1\").start(); new Thread(thread, \"窗口2\").start(); new Thread(thread, \"窗口3\").start(); } } * 解决方法二: 同步方法 如果操作共享数据的代码完整的声明在一个方法中，我们可以将此方法声明为同步的 1.同步方法仍然涉及到同步监视器，只是不需要我们显示的声明 2.非静态的同步方法，同步监视器是this：当前类的对象(实现Runnable接口) 3.静态的同步方法，同步监视器是：该方法所在类的class对象 class MyThread implements Runnable { private int ticket = 100; @Override public synchronized void run() { while (true) { if (ticket &gt; 0) { try { sleep(100); System.out.println(Thread.currentThread().getName() + \"卖出一张票，还剩： \" + ticket); } catch (InterruptedException e) { e.printStackTrace(); } ticket--; } else break; } } } public class Test1 { public static void main(String[] args) { MyThread thread = new MyThread(); new Thread(thread, \"窗口1\").start(); new Thread(thread, \"窗口2\").start(); new Thread(thread, \"窗口3\").start(); } } * 解决方法三: Lock锁 --JDK5.0新增 class Window implements Runnable{ private int ticket = 100; //1.创建ReentrantLock对象 private ReentrantLock lock = new ReentrantLock(true); @Override public void run() { while (true) { try { //2.调用上锁：lock()方法 lock.lock(); if (ticket &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"卖出一张票，还剩： \" + ticket); ticket--; }else break; } finally { //3.调用解锁：unlock()方法 lock.unlock(); } } } } public class Test1 { public static void main(String[] args) { MyThread thread = new MyThread(); new Thread(thread, \"窗口1\").start(); new Thread(thread, \"窗口2\").start(); new Thread(thread, \"窗口3\").start(); } } * 问题: synchronized与lock的异同 异: synchronized机制在执行完相应的同步代码快以后，自动释放同步监视器 Lock需要手动上、解锁 同: 都能解决线程安全问题 线程池线程池的好处: 1.提高响应速度 2.降低资源消耗 3.便于线程管理 class NumThread1 implements Runnable{ @Override public void run() { for (int i = 0; i &lt;= 100 ; i++) { if (i % 2 == 0){ System.out.println(Thread.currentThread().getName() + \":\" + i); } } } } class NumThread2 implements Runnable{ @Override public void run() { for (int i = 0; i &lt;= 100 ; i++) { if (i % 2 != 0){ System.out.println(Thread.currentThread().getName() + \":\" + i); } } } } public class ThreadPool { public static void main(String[] args) { //1.提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); //2.执行指定的线程操作，需要提供实现Runnable或者Callable接口的实现类 service.execute(new NumThread1()); //适合使用于Runnable //service.submit(); //适合适用于Callable service.execute(new NumThread2()); service.shutdown(); //关闭线程池 } } 线程间的通信实现线程的通信：交替打印1-100 wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器 notify():一旦被执行此方法，就唤醒被wait的一个线程，如果有多个，获取优先级高的 notifyAll():获取所有被wait的线程 说明： 1.wait() notify() notifyAll()三个方法必须使用在同步代码块或同步方法中 2.wait() notify() notifyAll()三个方法的调用者必须是同步代码块或同步方法中同步监视器 3.wait() notify() notifyAll()是定义在Object类中 sleep()和wait()方法的异同 同：一旦执行此方法，都会是当前线程进入阻塞状态 异：1.两个方法声明的位置不同：Thread类中声明sleep(), Object类中声明wait() 2.调用的要求不同：sleep()可以在任何需求的场景下调用，wait()必须在同步代码块中 3.关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁 class Number implements Runnable{ private int number = 1; @Override public void run() { while (true) { synchronized (this) { notify(); if (number &lt;= 100) { System.out.println(Thread.currentThread().getName() + \":\" + number); number++; try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } }else { break; } } } } 转载链接Java多线程（二） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"线程","slug":"线程","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java多线程(五)：读写锁、阻塞队列和自定义线程池","slug":"Java多线程（五）：读写锁、阻塞队列和自定义线程池","date":"2020-07-24T10:14:33.000Z","updated":"2020-07-24T10:34:03.449Z","comments":true,"path":"2020/07/24/Java多线程（五）：读写锁、阻塞队列和自定义线程池/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%AF%BB%E5%86%99%E9%94%81%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"Java多线程(五)：读写锁、阻塞队列和自定义线程池本文主要内容：读写锁、阻塞队列和自定义线程池 五、读写锁ReentrantReadWriteLock：读写锁出现就是为了更加方便的操作多条线程对资源的读写 readWriteLock.readLock()：读锁 == 共享锁 readWriteLock.writeLock()：写锁 == 独占锁 public class ReadWriteLockTest { public static void main(String[] args) { MyThreads myThreads = new MyThreads(); for (int i = 1; i &lt;= 5; i++) { final int temp = i; new Thread(() -&gt; { myThreads.write(temp + \"\", temp); }, String.valueOf(i)).start(); } for (int i = 1; i &lt;= 5; i++) { final int temp = i; new Thread(() -&gt; myThreads.read(temp + \"\"), String.valueOf(i)).start(); } } } class MyThreads{ private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 声明一个读写锁 private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); // 写入的时候只有一个线程可以写，不希望被其它线程插入(就是不希望在A线程正在写入和写入成功成功之间有其它线程进入) public void write(String key, Object value){ readWriteLock.writeLock().lock(); try { System.out.println(Thread.currentThread().getName() + \"正在写入\"); map.put(key, value); System.out.println(Thread.currentThread().getName() + \"写入成功\"); } catch (Exception e) { e.printStackTrace(); } finally { readWriteLock.writeLock().unlock(); } } // 读取的时候多条线程可以同时读取 public void read(String key){ readWriteLock.readLock().lock(); try { Object o = map.get(key); System.out.println(Thread.currentThread().getName() + \"读取成功\"); } catch (Exception e) { e.printStackTrace(); } finally { readWriteLock.readLock().unlock(); } } } 六、阻塞队列public class BlockingQueueTest { /** * 阻塞队列API一：add()与remove()方法 */ @Test public void test1(){ // 声明一个队列长度为3的阻塞队列 ArrayBlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(3); // 添加元素 System.out.println(queue.add(\"a\")); System.out.println(queue.add(\"b\")); System.out.println(queue.add(\"c\")); // 如果此时继续使用add方法会抛出异常(超过队列长度) java.lang.IllegalStateException: Queue full // System.out.println(queue.add(\"d\")); // 获取元素 System.out.println(queue.remove()); System.out.println(queue.remove()); System.out.println(queue.remove()); // 如果此时继续使用add方法会抛出异常(没有元素) java.util.NoSuchElementException // System.out.println(queue.remove()); } /** * 阻塞队列API二：offer()与poll()方法 */ @Test public void test2(){ // 声明一个队列长度为3的阻塞队列 ArrayBlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(3); // 添加元素 System.out.println(queue.offer(\"a\")); System.out.println(queue.offer(\"b\")); System.out.println(queue.offer(\"c\")); // 如果此时继续使用offer方法不会抛出异常，只会返回false System.out.println(queue.offer(\"d\")); // 获取元素 System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); // 如果此时继续使用offer方法不会抛出异常，只会返回null System.out.println(queue.poll()); } /** * 阻塞队列API三：put()与take()方法 */ @Test public void test3() throws InterruptedException { // 声明一个队列长度为3的阻塞队列 ArrayBlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(3); // 添加元素 queue.put(\"a\"); queue.put(\"b\"); queue.put(\"c\"); // 如果此时继续使用put方法不会抛出异常，只会一直阻塞 // queue.put(\"d\"); // 获取元素 System.out.println(queue.take()); System.out.println(queue.take()); System.out.println(queue.take()); //如果此时继续使用take方法不会抛出异常，只会一直阻塞 //System.out.println(queue.take()); } /** * 阻塞队列API四：offer()与poll()方法的带参版 */ @Test public void test4() throws InterruptedException { // 声明一个队列长度为3的阻塞队列 ArrayBlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(3); // 添加元素 System.out.println(queue.offer(\"a\")); System.out.println(queue.offer(\"b\")); System.out.println(queue.offer(\"c\")); // 如果此时继续使用offer方法传递2s，则会在2s之后退出阻塞 System.out.println(queue.offer(\"d\",2, TimeUnit.SECONDS)); // 获取元素 System.out.println(queue.poll()); System.out.println(queue.poll()); System.out.println(queue.poll()); // 如果此时继续使用poll方法传递2s，则会在2s之后退出阻塞 System.out.println(queue.poll(2, TimeUnit.SECONDS)); } } 四种情况分析 报出异常 不报异常 一直阻塞 超时退出 添加方法 add() offer() put() offer(参数) 删除方法 remove() poll() take() poll(参数) 七、线程池 创建线程池的三大方法 public class ThreadPool { public static void main(String[] args) { // 创建只有一个线程的线程池 // ExecutorService executor = Executors.newSingleThreadExecutor(); // 创建有自定义个线程的线程池 // ExecutorService executor = Executors.newFixedThreadPool(5); // 创建弹性线程池，根据需要的线程数量，自行创建 ExecutorService executor = Executors.newCachedThreadPool(); try { for (int i = 1; i &lt;= 5; i++) { executor.execute(() -&gt; { System.out.println(Thread.currentThread().getName()); }); } } catch (Exception e) { e.printStackTrace(); } finally { // 关闭线程池 executor.shutdown(); } } } 自定义线程池所需的七大参数和四种拒绝策略(因为我们需要规避默认创建线程池的OOM问题) public class ThreadPool { public static void main(String[] args) { // 创建自定义线程池 ExecutorService executor = new ThreadPoolExecutor( 2, // 池的核心大小 // 池的最大线程数：一般要根据需求确定是CPU密集型还是IO密集型 // CPU密集型：池的最大线程数为CPU核心数 Runtime.getRuntime().availableProcessors() --&gt; 获取CPU最大核心数 // IO密集型：池的池的最大线程数一般为频繁IO操作任务的数量 * 2 Runtime.getRuntime().availableProcessors(), 2, TimeUnit.SECONDS, // 超时过期时间 new LinkedBlockingQueue&lt;&gt;(3), // 阻塞队列 Executors.defaultThreadFactory(), // 创建线程工厂 // 拒绝策略1.new ThreadPoolExecutor.AbortPolicy() 线程池已经耗尽，如果还需要获取线程就直接抛出异常 // 拒绝策略2.new ThreadPoolExecutor.CallerRunsPolicy() 线程池已经耗尽，如果还需要获取线程，就直接让其回到创建线程的线程去执行(主线程) // 拒绝策略3.new ThreadPoolExecutor.DiscardPolicy() 线程池已经耗尽，如果还需要获取线程，就不去处理该方法即不抛出异常 // 拒绝策略4.new ThreadPoolExecutor.DiscardOldestPolicy() 线程池已经耗尽，如果还需要获取线程，就尝试和线程池最老线程争取资源 // 线程池的最大承载量为：池的最大线程数 + 阻塞队列可以容纳的容量 new ThreadPoolExecutor.AbortPolicy() ); try { for (int i = 1; i &lt;= 8; i++) { executor.execute(() -&gt; { System.out.println(Thread.currentThread().getName()); }); } } catch (Exception e) { e.printStackTrace(); } finally { // 关闭线程池 executor.shutdown(); } } } 转载链接Java多线程（五） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"线程","slug":"线程","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java多线程（一）","slug":"Java多线程（一）","date":"2020-07-24T10:14:33.000Z","updated":"2020-07-24T10:27:17.342Z","comments":true,"path":"2020/07/24/Java多线程（一）/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Java多线程(一)本文主要内容：创建线程的三种方式、线程的声明周期及状态变化、线程的调度 创建线程的三种方式1. 继承Thread类: class MyThread extends Thread { @Override public void run() { System.out.println(\"创建线程方式一\"); } } public class Test1 { public static void main(String[] args) { MyThread thread = new MyThread(); thread.start(); } } 2. 实现Runnable接口: class MyThread implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName() + \"创建线程方式二\"); } } public class Test1 { public static void main(String[] args) { MyThread thread = new MyThread(); //说明:Runnable接口创建线程需要先定义Runnable接口的实现类，然后创建Runnable实现类的实例作为参数传递给Thread new Thread(thread, \"Runnable接口创建的线程是\").start(); } } 3. 实现Callable接口和Future接口: class MyThread implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { int sum = 0; for (int i = 0; i &lt; 3; i++) { sum += i; } return sum; } } public class Test1 { public static void main(String[] args) { //1. 创建Callable接口的实现类对象 MyThread thread = new MyThread(); //2. 将此callable接口的实现类对象作为参数传递到FutureTask，创建FutureTask对象 FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(thread); //3. 将FutureTask对象作为参数传递到Thread的构造器中，并调用start方法 new Thread(task).start(); //4. 获取call()的返回值，通过FutureTask的对象的get()返回值即为Callable实现类重写call()的返回值 try { Integer o = task.get(); System.out.println(o); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } } 4. 三种创建线程的利弊: * 继承Thread类: 利: 如果要访问当前线程，无需使用Thread.currentThread()方法，直接使用this即可获得当前线程 弊: 线程类继承了Thread类，就不能继承其它类 * 实现Runnable接口: 利: 避免了单继承的局限性 弊: 如果要访问当前线程，需使用Thread.currentThread()方法 * 实现Callable接口和Future接口: 利: 避免了单继承的局限性，并且可以抛出异常和可以有返回值 弊: 如果要访问当前线程，需使用Thread.currentThread()方法 线程的声明周期及状态变化 新建状态:使用 new关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态: 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态:如果就绪状态的线程获取 CPU 资源， 就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态:如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。 死亡状态: 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 线程的调度1. 线程的优先级 * MAX_PRIORITY:10 MIN_PRIORITY:1 NORM_PRIORITY:5 * Thread类中的getPriority(): 获取当前线程的优先级 setPriority(): 设置当前线程的优先级 * 只是说优先级高被CPU执行的概率很高 2. 线程休眠: sleep()方法 class MyThread implements Runnable { @Override public void run() { try { for (int i = 0; i &lt; 5; i++) { System.out.println(\"当前时间: \" + new SimpleDateFormat(\"hh:mm:ss\").format(new Date())); sleep(2000); //打印5次当前时间，每次休眠2s } } catch (InterruptedException e) { e.printStackTrace(); } } } public class Test1 { public static void main(String[] args) { MyThread thread = new MyThread(); new Thread(thread).start(); } } 3. 线程让步: yield()方法 说明: yield()方法只是将正在执行的线程暂停，但不会让其阻塞，只会将其变为就绪状态，让线程调度器重新调度一次，但仍有可能将使用yield()方法的线程重新执行 4. 线程插队: join()方法 class MyThread implements Runnable { @Override public void run() { for (int i = 0; i &lt; 5; i++) { System.out.println(Thread.currentThread().getName()); } } } public class Test1 { public static void main(String[] args) { MyThread thread = new MyThread(); Thread t = new Thread(thread, \"线程1\"); t.start(); for (int i = 0; i &lt; 5; i++) { System.out.println(Thread.currentThread().getName()); if (i == 2) { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 转载链接Java多线程（一） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"线程","slug":"线程","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"[转载]LeanCloud配置教程","slug":"转载-LeanCloud配置教程","date":"2020-07-22T10:42:13.000Z","updated":"2020-07-24T12:46:10.578Z","comments":true,"path":"2020/07/22/转载-LeanCloud配置教程/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/22/%E8%BD%AC%E8%BD%BD-LeanCloud%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","excerpt":"","text":"LeanCloud配置教程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/hexo/"},{"name":"leancloud","slug":"leancloud","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/leancloud/"}]},{"title":"测试评论","slug":"测试评论","date":"2020-07-22T07:17:43.000Z","updated":"2020-07-22T07:26:34.435Z","comments":true,"path":"2020/07/22/测试评论/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/22/%E6%B5%8B%E8%AF%95%E8%AF%84%E8%AE%BA/","excerpt":"","text":"测试评论在下面评论 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"多线程与并发2","slug":"多线程与并发2","date":"2020-07-22T07:08:29.000Z","updated":"2020-07-22T07:35:51.230Z","comments":true,"path":"2020/07/22/多线程与并发2/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%912/","excerpt":"","text":"承接上文: 多线程与并发1 一. 多线程的特性1. 原子性原子性 , 即一个操作或多个操作要么全部执行并且执行过程中不会呗任何因素打断 , 要么就都不执行。 2. 有序性有序性即程序执行的顺序按照代码的先后顺序执行。 3. 可见性可见性是指当多个线程访问同一变量时 , 一个线程修改了这个变量的值 , 其它线程能够立即看得到修改的值。显然 , 对于单线程来说 , 可见性问题时不存在的。 二. 多线程控制类为了保证多线程的三个特性 , Java引入了很多线程控制机制 , 常用的有: ThreadLocal : 线程本地变量原子类 : 保证变量原子操作Lock类 : 保证线程有序性volatile关键字 : 保证线程变量可见性 1. ThreadLocal(1) 作用ThreadLocal提供线程局部变量 , 即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域(在线程内起作用)并且不同线程具有不同的数据副本时 , 就可以考虑采用ThreadLocal。比如数据库连接对象Connection , 每个请求处理线程都需要 , 但又不互相影响 , 就是用ThreadLocal实现。 (2) 常用APIinitalValue() : 副本创建方法get() : 获取副本方法set() : 设置副本方法 (3) 示例假如有两个用户 , 同时向同一家银行存款 , 那么每个用户就会对应一个账户余额 , 账户余额这个值就适合以副本形式创建。下面我们先来看运行代码: /* * @author WuZhengHua * @describe ThreadLocal保证线程三大特性 * @date 2020/03/28 */ public class BankTransfer { /** * 转账进银行 * * @param bank 银行 * @param money 金额 */ void transfer(Bank bank, Integer money) { try { System.out.println(Thread.currentThread().getName() + \"存钱中 ...\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } bank.setMoney(money); System.out.println(Thread.currentThread().getName() + \"存钱已存入 \" + money + \"元\"); System.out.println(Thread.currentThread().getName() + \"当前余额 \" + bank.getMoney() + \"元\"); } public static void main(String[] args) { BankTransfer bankTransfer = new BankTransfer(); //创建一个银行对象,两个用户都是同一个银行的 Bank bank = new Bank(); Thread thread1 = new Thread(new Runnable() { @Override public void run() { //连续转3笔帐(每一笔100元)进银行,最后账户的余额应该是300元 for (int i = 0; i &lt; 3; ++i) { bankTransfer.transfer(bank, 100); } } }, \"用户1\"); Thread thread2 = new Thread(new Runnable() { @Override public void run() { //连续转3笔帐(每一笔150元)进银行,最后账户的余额应该是450元 for (int i = 0; i &lt; 3; ++i) { bankTransfer.transfer(bank, 150); } } }, \"用户2\"); thread1.start(); thread2.start(); } } 如果上面代码的Bank类结构如下: class Bank { private Integer money = 0; /** * 存钱 * * @param money 金额 */ public void setMoney(Integer money) { this.money += money; } /** * 获取余额 * * @return 金额 */ public Integer getMoney() { return this.money; } } 我得到的输出结果为: 用户1存钱中 ... 用户2存钱中 ... 用户2存钱已存入 150元 用户1存钱已存入 100元 用户1当前余额 250元 用户2当前余额 250元 用户1存钱中 ... 用户2存钱中 ... 用户1存钱已存入 100元 用户1当前余额 350元 用户1存钱中 ... 用户2存钱已存入 150元 用户2当前余额 500元 用户2存钱中 ... 用户2存钱已存入 150元 用户2当前余额 600元 用户1存钱已存入 100元 用户1当前余额 600元 明显余额结果不正确 , 用户1应该最后拥有300元 , 用户2拥有450元 , 这是因为在创建线程时共用一个Bank对象 , 所以两个用户的金额保存在同一份中 , 所以应该使用ThreadLocal创建副本来管理各自的金额: class Bank { //创建账户金额副本,并定义初始值0 private ThreadLocal&lt;Integer&gt; money = new ThreadLocal&lt;Integer&gt;() { @Override protected Integer initialValue() { return 0; } }; /** * 存钱 * * @param money 金额 */ public void setMoney(Integer money) { this.money.set(getMoney() + money); } /** * 获取余额 * * @return 金额 */ public Integer getMoney() { return money.get(); } } //输出结果 用户2存钱中 ... 用户1存钱中 ... 用户2存钱已存入 150元 用户1存钱已存入 100元 用户2当前余额 150元 用户2存钱中 ... 用户1当前余额 100元 用户1存钱中 ... 用户2存钱已存入 150元 用户2当前余额 300元 用户2存钱中 ... 用户1存钱已存入 100元 用户1当前余额 200元 用户1存钱中 ... 用户2存钱已存入 150元 用户1存钱已存入 100元 用户1当前余额 300元 用户2当前余额 450元 (4) 实现原理① 在ThreadLocal类中定义了一个ThreadLocalMap对象 , 该对象是线程独有的 , 每一个线程都有一个ThreadLocalMap类型的变量threadLocals。② ThreadLocalMap内部有一个Entry对象 , Entry的key是ThreadLocal对象实例 , value就是共享变量副本。③ ThreadLocal的get方法就是根据ThreadLocal对象实例获取存在于ThreadLocalMap中的共享变量副本。③ ThreadLocal的set方法就是根据ThreadLocal对象实例修改存在于ThreadLocalMap中的共享变量副本。 2. 原子类(1) 简介和作用Java的java.util.concurrent.atomic包里面提供了很多可以进行原子操作的类 , 分为以下四类: 原子更新基本类型: AtomicInteger、AtomicBoolean、AtomicLong原子更新数组类型: AtomicIntegerArray、AtomicLongArray原子更新引用类型: AtomicReference、AtomicStampedReference等原子更新属性类型: AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。 (2) 示例i++操作是分为三个步骤的: int temp1 = i; int temp2 = temp1 + 1; i = temp2; 所以在多个线程对同个i同时i++时可能会出现问题 , 比如下面代码的输出结果预期应该都是2000: /* * @author WuZhengHua * @describe 原子类的使用 * @date 2020/03/29 */ public class AtomicCtrl { public static void main(String[] args) throws InterruptedException { for (int i = 0; i &lt; 100; ++i) { Atomic atomic = new Atomic(); Thread thread1 = new Thread(atomic); Thread thread2 = new Thread(atomic); thread1.start(); thread2.start(); //加入到主线程方便数值统计 thread1.join(); thread2.join(); System.out.println(\"第\" + i + \"次,n的值为: \" + atomic.getN()); } } } class Atomic implements Runnable { private int n = 0; public int getN() { return n; } @Override public void run() { for (int i = 0; i &lt; 1000; ++i) { n++; } } } //输出结果 第0次,n的值为: 2000 第1次,n的值为: 1552 第2次,n的值为: 2000 ... 但是我们发现结果中有一些并不是2000 , 这就是因为i++操作不是原子操作。这时候我们就可以使用原子类型: AtomicInteger 去代替int: class Atomic implements Runnable { //创建原子整型 , 并初始化值为0 private AtomicInteger n = new AtomicInteger(0); public AtomicInteger getN() { return n; } @Override public void run() { for (int i = 0; i &lt; 1000; ++i) { //获取到值再自增对应 i++ n.getAndIncrement(); } } } //输出结果 都是2000 这里补充一些AtomicInteger的常用API: getAndIncrement() : 对应n++incrementAndGet() : 对应++ngetAndDecrement() : 对应n–decrementAndGet() : 对应–n (3) CAS原理那么原子类型变量是如何实现原子操作的呢?答案就是CAS原理 , 我们来看看AtomicInteger的getAndIncrement()方法: /** * Atomically increments by one the current value. * * @return the previous value */ public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } unsafe是Sun公司提供的可以进行原子操作的工具类 , 这里getAndAddInt传入三个参数分别是: AtomicInteger实例this , 地址偏移量valueOffset , 增加阶数1下面我们来看看unsafe.getAndAddInt()方法: public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; } 解释一下上面的几个参数:var1 : 是当前值nvar2 : 是地址偏移量var5 : 是n的期望值(这里就是加1之后的值)var4 : 递增间隔(这里是1)CAS(比较并交换)原理: ① getIntVolatile()方法是根据当前值和地址偏移量获取Java堆中的期望值。② compareAndSwapInt()方法是比对 当前值(var1) 和期望值(var5) 是否相同:i 如果相同 , 说明线程更改过该值 , 当前值(var1) = 期望值(var5) + 递增间隔(var4) , 返回true。ii 如果不同 , 说明线程没有更改过该值 , 当前值(var1) = 期望值(var5) , 返回false。 3. Lock(1) 可重入锁与不可重入锁不可重入锁: 线程多次请求它已经拥有的锁时会发生阻塞。可重入锁: 线程可以进入它已经拥有的锁的同步代码块。 (2) 读写锁多个线程可以同时读，读的时候不能写。多个线程不能同时写，写的时候不能读。 /* * @author WuZhengHua * @describe 测试读写锁 * @date 2020/04/27 */ public class ReadWriteLockDemo { private Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //定义读写锁 private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock(); //获取读操作锁 private ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock(); //获取写操作锁 private ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock(); public String get(String key) { readLock.lock(); //读操作加锁 try { System.out.println(Thread.currentThread().getName() + \" 读操作已加锁, 开始执行读操作...\"); Thread.sleep(3000); return map.get(key); } catch (Exception e) { e.printStackTrace(); return null; } finally { readLock.unlock(); //解锁 System.out.println(Thread.currentThread().getName() + \" 读操作已解锁, 读操作结束...\"); } } public void put(String key, String value) { writeLock.lock(); //写操作加锁 try { System.out.println(Thread.currentThread().getName() + \" 写操作已加锁, 开始执行写操作...\"); Thread.sleep(3000); map.put(key, value); } catch (Exception e) { e.printStackTrace(); } finally { writeLock.unlock(); //解锁 System.out.println(Thread.currentThread().getName() + \" 写操作已解锁, 写操作结束...\"); } } public static void main(String[] args) { final ReadWriteLockDemo readWriteLockDemo = new ReadWriteLockDemo(); new Thread(\"写线程1\") { @Override public void run() { readWriteLockDemo.put(\"key1\", \"value1\"); } }.start(); new Thread(\"读线程1\") { @Override public void run() { System.out.println(readWriteLockDemo.get(\"key1\")); } }.start(); new Thread(\"写线程2\") { @Override public void run() { readWriteLockDemo.put(\"key1\", \"value1\"); } }.start(); new Thread(\"读线程2\") { @Override public void run() { System.out.println(readWriteLockDemo.get(\"key1\")); } }.start(); new Thread(\"读线程3\") { @Override public void run() { System.out.println(readWriteLockDemo.get(\"key1\")); } }.start(); } } //运行结果 写线程1 写操作已加锁, 开始执行写操作... 写线程1 写操作已解锁, 写操作结束... 读线程1 读操作已加锁, 开始执行读操作... 读线程1 读操作已解锁, 读操作结束... value1 写线程2 写操作已加锁, 开始执行写操作... 写线程2 写操作已解锁, 写操作结束... 读线程2 读操作已加锁, 开始执行读操作... 读线程3 读操作已加锁, 开始执行读操作... 读线程3 读操作已解锁, 读操作结束... value1 读线程2 读操作已解锁, 读操作结束... value1 4. volatile关键字(1) 作用一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义: ① 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其它线程来说是立即可见的。② 禁止进行指令重排序 补充一下何为指令重排序: int i = 0; i = 1; i = 2; i = 3; 如果变量i没有被volatile修饰，那么JVM在编译期会对代码进行优化，即i = 1;和i = 2;这两句代码是无效的，会直接忽略掉。进行了指令重排序。但是如果i被volatile修饰，有关i操作的代码都会被严格执行。这就是禁止了指令重排序。 (2) 使用条件① 对变量的写操作不依赖于当前值 //错误例子 volatile int i = 0; i = i + 1; //这里对于i的写操作依赖了i，所以不能使用volatile关键字修饰 ② 该变量没有包含在具有其它变量的不变式中 //错误例子 volatile int i = 0; int j = 1; j = i + j; //这里j和i同时出现在不变式中，不能使用volatile关键字修饰 (3) 应用场景 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"线程","slug":"线程","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"多线程与并发1","slug":"多线程与并发1","date":"2020-07-22T07:07:36.000Z","updated":"2020-07-22T07:26:24.098Z","comments":true,"path":"2020/07/22/多线程与并发1/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%911/","excerpt":"","text":"一. 并行与并发并行: 两个事件同一时间时进行并发: 两个事件同个时间段内进行 二. 进程与线程进程: 正在运行的程序的实例 , 进程是线程的容器。线程: 进程内部的一个独立执行单元 , 每个进程可以并发多个线程组成。多线程: 多个线程并发执行。 三. 线程创建Java中的四种线程创建方式: 继承Thread类实现Runnable接口实现Callable接口线程池 1. 继承Thread类/* * @author WuZhengHua * @describe 继承Thread创建线程 * @date 2020/03/24 */ public class MyThread extends Thread { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(\" MyThread执行了: \" + new Date().getTime()); try { Thread.sleep(50); //当前线程睡眠50ms } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { new MyThread().start(); for (int i = 0; i &lt; 10; i++) { System.out.println(\" 主线程执行了: \" + new Date().getTime()); try { Thread.sleep(50); //当前线程睡眠50ms } catch (InterruptedException e) { e.printStackTrace(); } } } } //输出结果 MyThread执行了: 1585035565928 主线程执行了: 1585035565928 主线程执行了: 1585035565982 MyThread执行了: 1585035565982 MyThread执行了: 1585035566044 主线程执行了: 1585035566044 MyThread执行了: 1585035566098 主线程执行了: 1585035566098 主线程执行了: 1585035566160 MyThread执行了: 1585035566160 主线程执行了: 1585035566214 MyThread执行了: 1585035566214 MyThread执行了: 1585035566283 主线程执行了: 1585035566283 主线程执行了: 1585035566345 MyThread执行了: 1585035566345 MyThread执行了: 1585035566399 主线程执行了: 1585035566399 主线程执行了: 1585035566461 MyThread执行了: 1585035566461 2. 实现Runnable接口/* * @author WuZhengHua * @describe 实现Runnable接口创建线程 * @date 2020/03/24 */ public class MyRunnable implements Runnable { @Override public void run() { System.out.println(\"MyRunnable线程执行了\"); } public static void main(String[] args) { //传入Runnable实现类和自定义线程名称 Thread thread = new Thread(new MyRunnable(),\"MyRunnable\"); thread.start(); } } //输出结果 MyRunnable线程执行了 3. 实现Callable接口这种方式创建的线程需要依赖FutureTask类 , 与上面两个不同的是 , 该方式可以获得线程执行完之后的返回值。 /* * @author WuZhengHua * @describe 实现Callable接口创建线程 * @date 2020/03/24 */ public class MyCallable implements Callable&lt;String&gt; { @Override public String call() throws Exception { System.out.println(\"MyCallable线程执行了\"); return \"MyCallable-return\"; } public static void main(String[] args) { FutureTask futureTask = new FutureTask(new MyCallable()); futureTask.run(); Object o = null; try { o = futureTask.get(); } catch (Exception e) { e.printStackTrace(); } System.out.println(o); } } //输出结果 MyCallable线程执行了 MyCallable-return 4. 线程池首先我们来了解一下什么是线程池 , 以及其内部有什么构成: Java提供了线程池以及操作线程池的工具类 , 这些类的关系如下: 通过线程池创建对象: /* * @author WuZhengHua * @describe 通过线程池创建对象 * @date 2020/03/24 */ public class MyThreadPool { public static void main(String[] args) { //FixedThreadPool固定线程数的线程池 , 这里创建一个10个线程的线程池 ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new MyRunnable()); //创建线程 , 传入线程 } } 四. 线程的状态学过操作系统这门课的同学应该都知道 , 线程分为五个状态: 初始状态-就绪状态-运行状态-阻塞状态-终止状态 , 下面我用一幅图来说明这五个状态的关系(图片出自&lt;&lt;码出高效 Java开发手册&gt;&gt;) 五. 线程安全问题如果一段代码单线程运行的结果跟多线程运行的结果不一致 , 就说明这个多线程存在安全问题 , 在开发中我们要避免这种线程安全问题 , 看一段代码: /* * @author WuZhengHua * @describe 票类,可以执行卖票操作 * @date 2020/03/24 */ public class Ticket implements Runnable { private int amount = 100; @Override public void run() { //不停卖票 while (true) { if(amount &lt;= 0){ break; } //售卖电影票 try { //让线程睡眠100ms Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } //打印售出的电影票编号 , 并且数量减 String name = Thread.currentThread().getName(); //获取到线程名称 System.out.println(name + \"售出电影票,编号: \" + amount--); } } public static void main(String[] args) { Ticket ticket = new Ticket(); Thread thread1 = new Thread(ticket, \"窗口1\"); Thread thread2 = new Thread(ticket, \"窗口2\"); Thread thread3 = new Thread(ticket, \"窗口3\"); thread1.start(); thread2.start(); thread3.start(); } } //输出结果 ... 窗口2售出电影票,编号: 10 窗口1售出电影票,编号: 8 窗口3售出电影票,编号: 9 窗口1售出电影票,编号: 7 窗口3售出电影票,编号: 5 窗口2售出电影票,编号: 6 窗口1售出电影票,编号: 4 窗口2售出电影票,编号: 3 窗口3售出电影票,编号: 4 窗口3售出电影票,编号: 2 窗口2售出电影票,编号: 1 窗口1售出电影票,编号: 0 窗口3售出电影票,编号: -1 从结果中我们看出 , 有些电影票被卖了多次(显然不符合逻辑) , 到最后甚至出现了0和-1的情况 , 原因就是因为Ticket类的amount变量被肆无忌惮地修改了 , 多个线程对共享数据同时具有写操作就是多线程安全问题。 六. 解决线程安全问题Java给我们提供了七种多线程同步的方式 , 这里我使用上面的例子来解决线程安全问题: 1.同步代码块(synchronized)创建一个锁对象 , 该对象可以理解为钥匙 , 一旦钥匙被某个线程拿到 , 其它线程就无法执行同步代码块 , 关键代码实现如下: //创建一个锁对象,相当于钥匙 private final Object object = new Object(); @Override public void run() { //使用同步代码块,这里传进去一个锁对象 synchronized (object) { //不停卖票 while (true) { if(amount &lt;= 0){ break; } //售卖电影票 try { //让线程睡眠100ms Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } //打印售出的电影票编号 , 并且数量减 String name = Thread.currentThread().getName(); //获取到线程名称 System.out.println(name + \"售出电影票,编号: \" + amount--); } } } //输出结果 ... 窗口1售出电影票,编号: 7 窗口1售出电影票,编号: 6 窗口1售出电影票,编号: 5 窗口1售出电影票,编号: 4 窗口1售出电影票,编号: 3 窗口1售出电影票,编号: 2 窗口1售出电影票,编号: 1 这里锁对象被第一个线程(窗口1)拿到了 , 且循环过程中没有释放过锁对象 , 所以其它线程就无法执行同步代码块中的代码(变成单线程执行)。 2.同步方法(synchronized)synchronized关键字也可以修饰方法(静态方法和非静态方法都可以) , 我们在上面代码的基础上定义一个同步方法: /** * 在方法前加synchronized关键字 , * 本质上也是创建了一个锁对象 * 如果该方法是非静态方法,锁对象就是当前方法的实例new Ticket() * 如果该方法时静态方法,锁对象就是当前静态方法所在的类Ticket.class */ private synchronized void saleTicket() { if(amount &lt;= 0){ break; } //售卖电影票 try { //让线程睡眠100ms Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } //打印售出的电影票编号 , 并且数量减 String name = Thread.currentThread().getName(); //获取到线程名称 System.out.println(name + \"售出电影票,编号: \" + amount--); } @Override public void run() { while (true) { //这个方法就是只允许一个线程访问的同步方法 saleTicket(); } } //输出结果 ... 窗口1售出电影票,编号: 7 窗口1售出电影票,编号: 6 窗口1售出电影票,编号: 5 窗口1售出电影票,编号: 4 窗口1售出电影票,编号: 3 窗口1售出电影票,编号: 2 窗口1售出电影票,编号: 1 3.同步锁通过上面两种方式 , 都是使用一个锁对象进行线程同步的 , Java为了优化这种同步方式, 可以检测锁的状态 , 体现面向对象 , 也提供了锁的机制 。Java提供了很多种锁 , 这里我们先以重入锁(ReenreantLock)为例。 /** * 创建重入锁 , 参数标识是否为公平锁 , * 这里设置为公平锁 , 每个线程都公平拥有执行权 , 所有线程都可以主动拿到这个锁 * 非公平锁(独占锁) , 默认值 , 一旦某个线程拿到锁之后就一直持有执行权直到主动释放 */ private Lock lock = new ReentrantLock(true); @Override public void run() { /* * 加锁方法 , 这个方法跟解锁方法unlock必须要成对出现 , 否则会出现死锁 * 所以我们经常使用try-finally语句块去保证不会出现死锁现象 */ while (true) { lock.lock(); try { //不停卖票,直到数量为0 if(amount &lt;= 0){ break; } //售卖电影票 try { //让线程睡眠100ms Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } //打印售出的电影票编号 , 并且数量减 String name = Thread.currentThread().getName(); //获取到线程名称 System.out.println(name + \"售出电影票,编号: \" + amount--); } finally { //执行解锁 lock.unlock(); } } } //输出结果 ... 窗口3售出电影票,编号: 8 窗口1售出电影票,编号: 7 窗口2售出电影票,编号: 6 窗口3售出电影票,编号: 5 窗口1售出电影票,编号: 4 窗口2售出电影票,编号: 3 窗口3售出电影票,编号: 2 窗口1售出电影票,编号: 1 4.特殊域变量(volatile)5.局部变量(ThreadLocal)6.阻塞队列(LinkedBlockingQueue)7.原子变量(Atomic*)七. 线程死锁1. 什么是死锁死锁是指多个线程因竞争资源而造成的一种僵局(互相等待) , 若无外力作用 , 这些进程都将无法向前推进。 2. 死锁产生的必要条件(1) 互斥条件进程要求对所分配的资源(如打印机)进行排他性控制 , 即在一段时间内某资源仅为一个线程所占有。此时若有其它线程请求该资源 , 则请求进程只能等待。(2) 不可剥夺条件进程所获得的资源在未使用完毕之前 , 不能被其他线程强行夺走 , 即只能由获得该资源的进程自己来释放(只能主动释放)。(3) 请求与保持条件进程已经保持了至少一个资源 , 但又提出了新的资源请求 , 而该资源已被其他进程占有 , 此时请求进程被阻塞 , 但对自己已获得的资源保持不放。(4) 循环等待条件存在一种进程资源的循环等待链 , 链中每一个进程已获得的资源同时被链中下一个进程所请求。 八. 线程通讯1. 为什么要使用线程通讯多线程并发执行时 , 默认情况下CPU是随机切换线程执行的 , 有时我们希望CPU按照我们安排的规律去执行线程 , 这时就需要线程之间协调通信。 2. 线程通讯方式线程间通讯常用方式有四种: (1) 休眠唤醒方式① Object 的 wait()、notify()、notifyAll()② Condition 的 await()、signal()、signalAll() 案例: 创建两个线程 , 一个线程打印0-10以内的奇数 , 另一个线程打印0-10以内的偶数 , 两个线程按1-10的顺序交替打印。 ① 使用Object实现 使用Object的wait()和notify()实现线程休眠和唤醒依赖synchronized关键字 , Object就是锁对象。 //存放待打印的数 private int i = 0; //使用Object的方法进行休眠唤醒 private final Object obj = new Object(); /** * 奇数打印方法 , 由奇数线程调用 */ public void odd() { while (i &lt; 10) { /** * 注意这里别忘了使用synchronized关键字 * 不然会报异常java.lang.IllegalMonitorStateException */ synchronized (obj) { if (i % 2 != 0) { //奇数,输出出来并加一 System.out.println(\"奇数: \" + i++); //唤醒偶数线程 obj.notify(); } else { try { //等待偶数线程执行 obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } //..偶数打印方法类似,这里省略了 public static void main(String[] args) { //创建当前实例 final PrintOddAndEven printOddAndEven = new PrintOddAndEven(); //开启奇数线程 Thread oddThread = new Thread(new Runnable() { @Override public void run() { printOddAndEven.odd(); } }); //开启偶数线程 Thread evenThread = new Thread(new Runnable() { @Override public void run() { printOddAndEven.even(); } }); oddThread.start(); evenThread.start(); } //输出结果 偶数: 0 奇数: 1 偶数: 2 奇数: 3 偶数: 4 奇数: 5 偶数: 6 奇数: 7 偶数: 8 奇数: 9 ② 使用Condition对象 Condition是依赖Lock对象进行线程休眠和唤醒的 , 这也是跟Object方式的区别 , 同样使用上面的例子 , 改用Condition进行线程休眠唤醒 , 参照上例 , 部分代码如下: /** * 创建Lock对象,注意这里是非公平锁 */ private Lock lock = new ReentrantLock(false); private Condition condition = lock.newCondition(); /** * 奇数打印方法 , 由奇数线程调用 */ public void odd() { while (i &lt; 10) { //加锁 lock.lock(); try { if (i % 2 != 0) { //奇数,输出出来并加一 System.out.println(\"奇数: \" + i++); //唤醒偶数线程 condition.signal(); } else { try { //等待偶数线程执行 condition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } } finally { //释放锁 lock.unlock(); } } } //输出结果 偶数: 0 奇数: 1 偶数: 2 奇数: 3 偶数: 4 奇数: 5 偶数: 6 奇数: 7 偶数: 8 奇数: 9 (2) CountDownLatch用于某个线程A等待若干其它线程执行完之后 , 它才执行。(即一等多)案例: 一个教练等待三个运动员准备完成再开始训练 /* * @author WuZhengHua * @describe CountDownLatch的使用 * @date 2020/03/26 */ public class CoachWaitRacer { //创建CountDownLatch对象,构造函数需要传入需要等待的线程数量 private CountDownLatch countDownLatch = new CountDownLatch(3); /** * 教练 */ public void coach() { String name = Thread.currentThread().getName(); try { Thread.sleep(1000); System.out.println(name + \"准备完毕,等待运动员...\"); countDownLatch.await(); System.out.println(\"运动员全部到齐,开始训练!\"); } catch (InterruptedException e) { e.printStackTrace(); } } /** * 运动员 */ public void racer() { String name = Thread.currentThread().getName(); System.out.println(name + \"开始准备...\"); try { Thread.sleep(1000); System.out.println(name + \"准备完毕!\"); //调用计数器减一 countDownLatch.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } } public static void main(String[] args) { final CoachWaitRacer coachWaitRacer = new CoachWaitRacer(); Thread thread = new Thread(new Runnable() { @Override public void run() { coachWaitRacer.coach(); } }, \"教练\"); Thread thread1 = new Thread(new Runnable() { @Override public void run() { coachWaitRacer.racer(); } }, \"运动员1\"); Thread thread2 = new Thread(new Runnable() { @Override public void run() { coachWaitRacer.racer(); } }, \"运动员2\"); Thread thread3 = new Thread(new Runnable() { @Override public void run() { coachWaitRacer.racer(); } }, \"运动员3\"); thread.start(); thread1.start(); thread2.start(); thread3.start(); } } //输出结果 运动员1开始准备... 运动员3开始准备... 运动员2开始准备... 运动员2准备完毕! 教练准备完毕,等待运动员... 运动员1准备完毕! 运动员3准备完毕! 运动员全部到齐,开始训练! (3) CyclicBarrier一组线程等待至某个状态之后再全部执行。(同时阻塞)案例: 运动员准备完成都到了起跑线才能开始比赛。 /* * @author WuZhengHua * @describe CyclicBarrier的使用 * @date 2020/03/26 */ public class RacerGo { /** * 创建cyclicBarrier对象,传入线程组的线程数,即需要互相等待的线程数 */ CyclicBarrier cyclicBarrier = new CyclicBarrier(3); public void racerStart() { String name = Thread.currentThread().getName(); try { Thread.sleep(1000); System.out.println(name + \"准备完毕\"); //调用await方法,只有当三个线程到达同一状态时才继续往下执行(即三个线程都执行到该方法) cyclicBarrier.await(); System.out.println(new Date().getTime() + \" 跑!\"); } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } } public static void main(String[] args) { final RacerGo racerGo = new RacerGo(); new Thread(new Runnable() { @Override public void run() { racerGo.racerStart(); } }, \"运动员1\").start(); new Thread(new Runnable() { @Override public void run() { racerGo.racerStart(); } }, \"运动员2\").start(); new Thread(new Runnable() { @Override public void run() { racerGo.racerStart(); } }, \"运动员3\").start(); } } //输出结果 运动员2准备完毕 运动员3准备完毕 运动员1准备完毕 1585233005512 跑! 1585233005512 跑! 1585233005512 跑! (4) Semaphore用于控制对某组资源的访问权限。案例: 假如有5个工人 , 3台机器 , 每台机器只允许一人使用。即5个线程使用3个资源 , 每个资源只能由一个线程占有。 /* * @author WuZhengHua * @describe Semaphore的使用 * @date 2020/03/27 */ public class WorkersAndMachine { Semaphore semaphore = new Semaphore(3); //三台机器,三个资源 /** * 工人工作 */ public void doWork() { String name = Thread.currentThread().getName(); System.out.println(name + \"准备工作,请求一台机器 \"+new Date().getTime()); try { //请求一个资源 semaphore.acquire(); System.out.println(name+\"拿到机器,开始工作... \"+new Date().getTime()); //工作了1000ms Thread.sleep(2000); //使用完毕,释放一个资源 semaphore.release(); System.out.println(name + \"完成工作,释放机器! \"+new Date().getTime()); } catch (InterruptedException e) { e.printStackTrace(); } } public static void main(String[] args) { final WorkersAndMachine workersAndMachine = new WorkersAndMachine(); //5个工人,创建5个线程 for (int i = 0; i &lt; 5; ++i) { new Thread(new Runnable() { @Override public void run() { workersAndMachine.doWork(); } }, \"工人\" + i).start(); } } } //输出结果 工人1准备工作,请求一台机器 1585323284818 工人2准备工作,请求一台机器 1585323284818 工人1拿到机器,开始工作... 1585323284818 工人0准备工作,请求一台机器 1585323284818 工人4准备工作,请求一台机器 1585323284818 工人3准备工作,请求一台机器 1585323284818 工人0拿到机器,开始工作... 1585323284818 工人2拿到机器,开始工作... 1585323284818 工人1完成工作,释放机器! 1585323286823 工人4拿到机器,开始工作... 1585323286823 工人0完成工作,释放机器! 1585323286823 工人3拿到机器,开始工作... 1585323286823 工人2完成工作,释放机器! 1585323286823 工人3完成工作,释放机器! 1585323288829 工人4完成工作,释放机器! 1585323288829 Question1. 使用多线程的目的是什么?充分利用cpu资源 , 并发进行多个任务 2. 单核CPU机器上适不适合多线程?适合 , 如果是单核CPU , 在线程中也可能需要等待IO , 此时CPU就空闲下来了 , 可以给其它线程使用。但是一定要考虑其创建线程+销毁线程的时间是否超过了任务执行时间 , 考虑是否值得创建线程。 3. 线程什么时候会让出CPU?(1) 阻塞时 wait await 等待IO(2) sleep(3) yield(4) 线程结束 4. 线程是什么?一组代码执行流 , 完成一组代码的执行这一组代码 , 我们可以称为一个任务 5. CPU做的是什么工作?执行代码 6. 线程是不是越多越好?(1) 线程在Java中是一个对象 , 每一个Java线程都需要一个操作系统线程支持。线程创建、销毁都需要时间。如果创建时间+销毁时间 &gt; 任务执行时间 , 就很不合算*。(2) Java对象占用堆内存 , 操作系统线程占用系统内存 , 根据JVM规范 , 一个线程默认最大栈大小为1M , 这个栈空间是需要从系统内存中分配的。*线程过多 , 会消耗很多内存。(3) 操作系统需要频繁切换线程上下文(所有线程都需要被执行) , 影响性能。 7. 如何正确使用多线程?多线程的目的: 充分利用CPU并发执行代码。线程的本质: 将代码提交给CPU执行。用合适数量的线程不断运送代码即可。这些合适数量的线程就构成了一个池-线程池。 8. synchronized和Lock的区别是什么?(1) synchronized是Java内置的关键字 , 是在JVM层面上的。而Lock是一个Java类。(2) synchronized无法判断是否获取锁的状态。Lock可以判断是否获取到锁。(3) synchronized在执行完后会自动释放锁。而Lock必须要手动释放锁 , 否则会出现死锁。(4) synchronized的锁可重入、不可中断、非公平。Lock锁可重入、可判断、可设置是否公平。(5) synchronized适合给少量代码加锁。Lock适合给大量代码加锁。 7. wait()和sleep()的区别是什么? wait() sleep() 同步 只能在同步上下文中调用wait方法 , 否则或抛出IllegalMonitorStateException异常 不需要再同步方法或同步代码块中使用 作用对象 wait方法定义在Object类中 , 作用与(锁)对象本身 sleep方法定义在java.lang.Thread中 , 作用于当前线程 释放锁资源 是 , 调用wait()方法后锁资源就被释放了 否 , 调用sleep()后仍然占有锁资源 唤醒条件 其它线程调用notify()或者notifyAll()方法 超时或者调用interrupt()方法体 方法属性 Object对象的实例方法 Thread类的静态方法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"线程","slug":"线程","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"什么是微服务，SpringBoot和SpringCloud的关系","slug":"什么是微服务，SpringBoot和SpringCloud的关系","date":"2020-07-21T18:41:14.000Z","updated":"2020-07-22T07:23:36.218Z","comments":true,"path":"2020/07/22/什么是微服务，SpringBoot和SpringCloud的关系/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/22/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8CSpringBoot%E5%92%8CSpringCloud%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"","text":"什么是微服务就目前而言对于微服务业界没有一个统一的,标准的定义.但通常而言,微服务是一种架构模式或者说是一种架构风格,它提倡单一应用程序划分为一组小的服务,每个服务在其独立的自己的进程中,服务之间相互协调,互相配合,为用户提供最终价值.服务之间采用轻量级的通信机制互相沟通(基于Http的Restful API)每个服务都围绕着具体的业务进行构建,并且能够被独立的部署到生产环境,类生产环境进行构建,可以有一个非常轻量级的集中式管理来协调这些服务,可以使用不同的语言来编写服务,也可以使用不同的数据存储. 微服务与微服务架构? 微服务强调的是服务的大小,关注的是点,是具体解决某一个问题/提供落地对象服务的一个服务应用, 狭义的看,可以看做Eclipse中的一个个微服务工程. 微服务架构为一种架构模式.他提倡将单一应用程序分成一组小的服务,服务之间互相协调,互相配合,为用户提供最终价值. 每个服务运行在其独立的进程中,服务于服务间采用轻量级的通信机制互相协作(通常是Http 的Restful API) 每一个服务 都围绕着具体业务进行构建,并且能够被独立的部署到生产环境,类生产环境中.另外,应当尽量避免统一的,集中式的服务管理机制, 对具体的一个服务而言,应根据业务上下文,选择合适的语言,工具对其进行构建. SpringCloud 是什么? 基于SpringBoot提供了一套为微服务(microservices)解决方案,包括服务注册与发现, 配置中心,全链路监控,服务网关,负载均衡,熔断器等组件,除了基于NetFlix的开营组件做 高度抽象之外,还有一些选型中立了的开源组件. 分布式微服务架构下的一站式解决方案,是各个微服务架构落地技术的结合体,俗称为微服务全家桶. SpringBoot和SpringCloud的关系和区别 SpringBoot专注于方便的开发单个个体微服务 SpringCloud是关注于全局的微服务协调治理框架,它将SpringBoot开发的一个个单体微服务整合并管理起来.为各个微服务之间提供配置管理,服务发现,断路器,路由,微代理,事件总线,决策竞选,分布式会话等集成服务. SpringBoot可以离开SpringCloud单独使用,而SpringCloud离不开SpringBoot document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/springboot/"},{"name":"springcloud","slug":"springcloud","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/springcloud/"}]},{"title":"将maven源改为国内阿里云镜像","slug":"将maven源改为国内阿里云镜像","date":"2020-07-21T18:41:02.000Z","updated":"2020-07-22T07:23:41.248Z","comments":true,"path":"2020/07/22/将maven源改为国内阿里云镜像/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/22/%E5%B0%86maven%E6%BA%90%E6%94%B9%E4%B8%BA%E5%9B%BD%E5%86%85%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F/","excerpt":"","text":"&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;localRepository/&gt; &lt;interactiveMode/&gt; &lt;usePluginRegistry/&gt; &lt;offline/&gt; &lt;pluginGroups/&gt; &lt;servers/&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public &lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;proxies/&gt; &lt;profiles/&gt; &lt;activeProfiles/&gt; &lt;/settings&gt; &lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public &lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;/settings&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"maven","slug":"maven","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/maven/"}]},{"title":"SSM中各层作用及关系","slug":"SSM中各层作用及关系","date":"2020-07-21T18:40:49.000Z","updated":"2020-07-22T07:26:40.219Z","comments":true,"path":"2020/07/22/SSM中各层作用及关系/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/22/SSM%E4%B8%AD%E5%90%84%E5%B1%82%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%85%B3%E7%B3%BB/","excerpt":"","text":"持久层：DAO层（mapper层）（属于mybatis模块） DAO层：主要负责与数据库进行交互设计，用来处理数据的持久化工作。 DAO层的设计首先是设计DAO的接口，也就是项目中看到的Dao包。 然后在Spring的xml配置文件中定义此接口的实现类，就可在其他模块中调用此接口来进行数据业务的处理，而不用关心接口的具体实现类是哪个类，这里往往用到的就是反射机制，DAO层的jdbc.properties数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。 有的项目Dao层，写成mapper，当成一个意思理解。 业务层：Service层（属于spring模块） Service层：主要负责业务模块的逻辑应用设计。也就是项目中看到的Service包。 Service层的设计首先是设计接口，再设计其实现的类。也就是项目中看到的service+impl包。 接着再在Spring的xml配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。 最后通过调用DAO层已定义的接口，去实现Service具体的实现类。 Service层的业务实现，具体要调用到已定义的DAO层的接口。 控制层/表现层：Controller层（Handler层） （属于springMVC模块） Controller层：主要负责具体的业务模块流程控制，也就是看到的controller包。 Controller层通过要调用Service层的接口来控制业务流程，控制的配置也同样是在Spring的xml配置文件里面，针对具体的业务流程，会有不同的控制器。 View层 （属于springMVC模块） 负责前台jsp页面的展示，此层需要与Controller层结合起来开发。 Jsp发送请求，controller接收请求，处理，返回，jsp回显数据。 各层之间的联系 DAO层，Service层这两个层次可以单独开发，互相的耦合度很低。 Controller，View层耦合度比较高，因而要结合在一起开发。也可以听当做两层来开发，这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，项目会显得清晰简单。 值得注意的是，Service逻辑层设计：Service层是建立在DAO层之上的，在Controller层之下。因而Service层应该既调用DAO层的接口，又提供接口给Controller层的类来进行调用，它处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。 SSM框架实现一个web程序主要使用到如下三个技术： Spring：用到注解和自动装配，就是Spring的两个精髓IOC(反向控制)和 AOP(面向切面编程)。 SpringMVC：用到了MVC模型，将流程控制代码放到Controller层处理，将业务逻辑代码放到Service层处理。 Mybatis：用到了与数据库打交道的层面，dao（mapper）层，放在所有的逻辑之后，处理与数据库的CRUD相关的操作。 开发项目的时候，需要完成一个功能模块 先写实体类entity，定义对象的属性，（可以参照数据库中表的字段来设置，数据库的设计应该在所有编码开始之前）。 写Mapper.xml（Mybatis），其中定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。 写Mapper.java/Dao.java，将Mapper.xml中的操作按照id映射成Java函数。实际上就是Dao接口，二者选一即可。 写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。 写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。 写JSP页面调用，请求哪些参数，需要获取什么数据。 面向对象——三层架构（表现层、业务层、持久层）三层架构：即表现层、业务层、持久层。 持久层：采用DAO模式，建立实体类和数据库表映射（ORM映射）。也就是哪个类对应哪个表，哪个属性对应哪个列。持久层的目的就是，完成对象数据和关系数据的转换。 业务层：采用事务脚本模式。将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作，即保证同时成功或同时失败。避免部分成功部分失败引起的数据混乱操作。 表现层：采用MVC模式。M称为模型，也就是实体类。用于数据的封装和数据的传输。V为视图，也就是GUI组件，用于数据的展示。C为控制，也就是事件，用于流程的控制 业务层接口的设计原则：一个实体类一个接口，一次提交一个业务方法。业务方法的参数自表现层。 持久层接口的设计原则：一个实体类一个接口，一次数据库操作一个持久方法。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"sring","slug":"sring","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/sring/"},{"name":"springmvc","slug":"springmvc","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/springmvc/"},{"name":"mybatis","slug":"mybatis","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/mybatis/"}]},{"title":"Redis基础学习","slug":"Redis基础学习","date":"2020-07-21T18:40:31.000Z","updated":"2020-07-22T07:26:44.635Z","comments":true,"path":"2020/07/22/Redis基础学习/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/22/Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"Redis基础学习Redis 概念: Redis是一款高性能的NoSQL系列的非关系型数据库 命令操作: Redis的数据结构: Redis存储的是: key-value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构: 字符串类型: String 哈希类型: hash(Map类型) 列表类型: list(Linkedlist) 集合类型: set 有序列表类型: sortedset 字符串类型 string 存储: set key value 获取: get key 删除: del key","text":"Redis基础学习Redis 概念: Redis是一款高性能的NoSQL系列的非关系型数据库 命令操作: Redis的数据结构: Redis存储的是: key-value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构: 字符串类型: String 哈希类型: hash(Map类型) 列表类型: list(Linkedlist) 集合类型: set 有序列表类型: sortedset 字符串类型 string 存储: set key value 获取: get key 删除: del key 哈希类型 hash 存储: hset key field value 获取: hget key field 删除: hdel key field 获取hash中的所有键和值: hgetall key 列表类型 list 存储: lpush key value: 从左添加 rpush key value: 从右添加 获取: lrange key start end: 范围获取(0 -1代表获取全部) 删除: lpop key: 删除列表最左边的元素，并返回 rpop key: 删除列表最右边的元素，并返回 集合类型 set: 不允许重复元素(且无序) 存储: sadd key value value1 value2 …. 获取: smembers key: 获取set集合中的所有元素 删除: srem key value: 删除set集合中的某个元素 有序集合类型 sortedset: 不允许有重复元素，不同的是每个元素会有一个double类型的分数(权重)，按照此分数进行排序 存储: zadd key score value 获取: zrange key start end 删除: zrem key value 通用命令 keys * : 查询所有的键 type key : 获取键对应的value的类型 del key: 删除指定的key value 持久化 Redis是一个内存数据库，当Redis服务器或电脑重启，数据会丢失，我们可以将Redis内存中的数据持久化保存到硬盘文件中 Redis持久化机制 RDB: 默认方式，不需要进行配置，默认使用 在一定间隔事件中，检测key的变化情况，然后持久化数据 编辑redis.windows.conf文件 save 900 1(15分钟有一个key变化就持久化) save 300 10 save 60 10000 重新启动redis服务器并指定conf cmd启动服务器: redis-server.exe redis.windows.conf AOF: 日志记录的方法，可以记录每一条命令的操作，然后持久化操作(不推荐) 编辑redis.windows.conf appendonly no(关闭aof) –&gt; appendonly yes appendfsync always: 每一次操作都进行持久化 appendfsync everysec: 每隔一秒都进行一次持久化 appendfsync no : 不进行持久化 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/redis/"}]},{"title":"git 使用（ssh key创建和github使用）","slug":"git-使用（ssh-key创建和github使用）","date":"2020-07-17T18:38:48.000Z","updated":"2020-07-22T07:27:38.104Z","comments":true,"path":"2020/07/18/git-使用（ssh-key创建和github使用）/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/07/18/git-%E4%BD%BF%E7%94%A8%EF%BC%88ssh-key%E5%88%9B%E5%BB%BA%E5%92%8Cgithub%E4%BD%BF%E7%94%A8%EF%BC%89/","excerpt":"","text":"ssh用于验证，https://github.com/ 需要，https://www.cloudcontrol.com/onboarding/ssh也需要。git使用记录git是分布式的代码管理工具，远程的代码管理是基于ssh的，所以要使用远程的git则需要ssh的配置。 github的ssh配置如下： 一 、设置git的user name和email：$ git config --global user.name \"xuhaiyan\" $ git config --global user.email \"haiyan.xu.vip@gmail.com\"二、生成SSH密钥过程：1.查看是否已经有了ssh密钥：cd ~/.ssh如果没有密钥则不会有此文件夹，有则备份删除2.生存密钥： $ ssh-keygen -t rsa -C “haiyan.xu.vip@gmail.com” 按3个回车，密码为空。 Your identification has been saved in /home/tekkub/.ssh/id_rsa. Your public key has been saved in /home/tekkub/.ssh/id_rsa.pub. The key fingerprint is: ……………… 最后得到了两个文件：id_rsa和id_rsa.pub 3.添加密钥到ssh：ssh-add 文件名 需要之前输入密码。4.在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。 打开https://github.com/ ，登陆xuhaiyan825，然后添加ssh。 5.测试：ssh git@github.com The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘github.com,207.97.227.239′ (RSA) to the list of known hosts.ERROR: Hi tekkub! You’ve successfully authenticated, but GitHub does not provide shell accessConnection to github.com closed. 三、 开始使用github1.获取源码： $ git clone git@github.com:billyanyteen/github-services.git2.这样你的机器上就有一个repo了。3.git于svn所不同的是git是分布式的，没有服务器概念。所有的人的机器上都有一个repo，每次提交都是给自己机器的repo仓库初始化： git init生成快照并存入项目索引： git add文件,还有git rm,git mv等等…项目索引提交： git commit4.协作编程：将本地repo于远程的origin的repo合并，推送本地更新到远程： git push origin master更新远程更新到本地： git pull origin master补充：添加远端repo： $ git remote add upstream git://github.com/pjhyett/github-services.git重命名远端repo： $ git://github.com/pjhyett/github-services.git为“upstream” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/github/"}]},{"title":"使用Hexo+github搭建一个属于自己的服务器","slug":"使用Hexo+github搭建一个属于自己的服务器","date":"2020-05-31T18:41:27.000Z","updated":"2020-07-22T07:23:29.162Z","comments":true,"path":"2020/06/01/使用Hexo+github搭建一个属于自己的服务器/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/06/01/%E4%BD%BF%E7%94%A8Hexo+github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"安装Nodejsnode -v #查看node版本 npm -v #查看npm版本 npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器 cnpm -v #查看cnpm版本 cnpm install -g hexo-cli #安装hexo框架 hexo -v #查看hexo版本 mkdir blog #创建blog目录 cd blog #进入blog目录 sudo hexo init #生成博客 初始化博客 hexo s #启动本地博客服务 http://localhost:4000/ #本地访问地址 hexo n “我的第一篇文章” #创建新的文章 返回blog目录 hexo clean #清理 hexo g #生成 Github创建一个新的仓库 YourGithubName.github.io cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件 配置_config.ymlDeployment Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/YourGithubName/YourGithubName.github.io.git branch: master hexo d #部署到Github仓库里 https://YourGithubName.github.io/ #访问这个地址可以查看博客 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载yilia主题到本地 #修改hexo根目录下的 _config.yml 文件 ： theme: yilia hexo c #清理一下 hexo g #生成 hexo d #部署到远程Github仓库 视频链接：https://www.bilibili.com/video/BV1Yb411a7ty?t=1486 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/hexo/"}]},{"title":"hello world","slug":"hello world","date":"2020-05-31T18:32:06.000Z","updated":"2020-07-22T07:27:05.471Z","comments":true,"path":"2020/06/01/hello world/","link":"","permalink":"https://github.com/Holuyi/holuyi.github.io/2020/06/01/hello%20world/","excerpt":"","text":"记录第一条博客 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"hello world","slug":"hello-world","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/hello-world/"}]}],"categories":[],"tags":[{"name":"集合","slug":"集合","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"线程","slug":"线程","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"hexo","slug":"hexo","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/hexo/"},{"name":"leancloud","slug":"leancloud","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/leancloud/"},{"name":"测试","slug":"测试","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"springboot","slug":"springboot","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/springboot/"},{"name":"springcloud","slug":"springcloud","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/springcloud/"},{"name":"maven","slug":"maven","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/maven/"},{"name":"sring","slug":"sring","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/sring/"},{"name":"springmvc","slug":"springmvc","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/springmvc/"},{"name":"mybatis","slug":"mybatis","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/mybatis/"},{"name":"redis","slug":"redis","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/redis/"},{"name":"github","slug":"github","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/github/"},{"name":"hello world","slug":"hello-world","permalink":"https://github.com/Holuyi/holuyi.github.io/tags/hello-world/"}]}