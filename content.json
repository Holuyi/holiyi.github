{"meta":{"title":"Holuyi's Blog","subtitle":"","description":"","author":"Holuyi","url":"https://holuyi.gitee.io","root":"/"},"pages":[{"title":"404","date":"2020-07-21T17:15:46.000Z","updated":"2020-07-21T17:16:29.964Z","comments":true,"path":"404.html","permalink":"https://holuyi.gitee.io/404.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-07-21T17:05:03.000Z","updated":"2020-07-21T17:05:34.349Z","comments":true,"path":"categories/index.html","permalink":"https://holuyi.gitee.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-07-21T17:05:43.000Z","updated":"2020-07-21T17:06:12.663Z","comments":true,"path":"tags/index.html","permalink":"https://holuyi.gitee.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-07-21T17:06:49.000Z","updated":"2020-07-21T17:07:14.482Z","comments":true,"path":"contact/index.html","permalink":"https://holuyi.gitee.io/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"[转载]LeanCloud配置教程","slug":"转载-LeanCloud配置教程","date":"2020-07-22T10:42:13.000Z","updated":"2020-07-22T10:43:54.429Z","comments":true,"path":"2020/07/22/转载-LeanCloud配置教程/","link":"","permalink":"https://holuyi.gitee.io/2020/07/22/%E8%BD%AC%E8%BD%BD-LeanCloud%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/","excerpt":"","text":"LeanCloud配置教程 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"-leancloud -hexo","slug":"leancloud-hexo","permalink":"https://holuyi.gitee.io/tags/leancloud-hexo/"}]},{"title":"测试评论","slug":"测试评论","date":"2020-07-22T07:17:43.000Z","updated":"2020-07-22T07:26:34.435Z","comments":true,"path":"2020/07/22/测试评论/","link":"","permalink":"https://holuyi.gitee.io/2020/07/22/%E6%B5%8B%E8%AF%95%E8%AF%84%E8%AE%BA/","excerpt":"","text":"测试评论在下面评论 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://holuyi.gitee.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"多线程与并发2","slug":"多线程与并发2","date":"2020-07-22T07:08:29.000Z","updated":"2020-07-22T07:35:51.230Z","comments":true,"path":"2020/07/22/多线程与并发2/","link":"","permalink":"https://holuyi.gitee.io/2020/07/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%912/","excerpt":"","text":"承接上文: 多线程与并发1 一. 多线程的特性1. 原子性原子性 , 即一个操作或多个操作要么全部执行并且执行过程中不会呗任何因素打断 , 要么就都不执行。 2. 有序性有序性即程序执行的顺序按照代码的先后顺序执行。 3. 可见性可见性是指当多个线程访问同一变量时 , 一个线程修改了这个变量的值 , 其它线程能够立即看得到修改的值。显然 , 对于单线程来说 , 可见性问题时不存在的。 二. 多线程控制类为了保证多线程的三个特性 , Java引入了很多线程控制机制 , 常用的有: ThreadLocal : 线程本地变量原子类 : 保证变量原子操作Lock类 : 保证线程有序性volatile关键字 : 保证线程变量可见性 1. ThreadLocal(1) 作用ThreadLocal提供线程局部变量 , 即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域(在线程内起作用)并且不同线程具有不同的数据副本时 , 就可以考虑采用ThreadLocal。比如数据库连接对象Connection , 每个请求处理线程都需要 , 但又不互相影响 , 就是用ThreadLocal实现。 (2) 常用APIinitalValue() : 副本创建方法get() : 获取副本方法set() : 设置副本方法 (3) 示例假如有两个用户 , 同时向同一家银行存款 , 那么每个用户就会对应一个账户余额 , 账户余额这个值就适合以副本形式创建。下面我们先来看运行代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * @author WuZhengHua * @describe ThreadLocal保证线程三大特性 * @date 2020/03/28 */public class BankTransfer { /** * 转账进银行 * * @param bank 银行 * @param money 金额 */ void transfer(Bank bank, Integer money) { try { System.out.println(Thread.currentThread().getName() + \"存钱中 ...\"); Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } bank.setMoney(money); System.out.println(Thread.currentThread().getName() + \"存钱已存入 \" + money + \"元\"); System.out.println(Thread.currentThread().getName() + \"当前余额 \" + bank.getMoney() + \"元\"); } public static void main(String[] args) { BankTransfer bankTransfer = new BankTransfer(); //创建一个银行对象,两个用户都是同一个银行的 Bank bank = new Bank(); Thread thread1 = new Thread(new Runnable() { @Override public void run() { //连续转3笔帐(每一笔100元)进银行,最后账户的余额应该是300元 for (int i = 0; i &lt; 3; ++i) { bankTransfer.transfer(bank, 100); } } }, \"用户1\"); Thread thread2 = new Thread(new Runnable() { @Override public void run() { //连续转3笔帐(每一笔150元)进银行,最后账户的余额应该是450元 for (int i = 0; i &lt; 3; ++i) { bankTransfer.transfer(bank, 150); } } }, \"用户2\"); thread1.start(); thread2.start(); }} 如果上面代码的Bank类结构如下: 123456789101112131415161718192021class Bank { private Integer money = 0; /** * 存钱 * * @param money 金额 */ public void setMoney(Integer money) { this.money += money; } /** * 获取余额 * * @return 金额 */ public Integer getMoney() { return this.money; }} 我得到的输出结果为: 123456789101112131415161718用户1存钱中 ...用户2存钱中 ...用户2存钱已存入 150元用户1存钱已存入 100元用户1当前余额 250元用户2当前余额 250元用户1存钱中 ...用户2存钱中 ...用户1存钱已存入 100元用户1当前余额 350元用户1存钱中 ...用户2存钱已存入 150元用户2当前余额 500元用户2存钱中 ...用户2存钱已存入 150元用户2当前余额 600元用户1存钱已存入 100元用户1当前余额 600元 明显余额结果不正确 , 用户1应该最后拥有300元 , 用户2拥有450元 , 这是因为在创建线程时共用一个Bank对象 , 所以两个用户的金额保存在同一份中 , 所以应该使用ThreadLocal创建副本来管理各自的金额: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Bank { //创建账户金额副本,并定义初始值0 private ThreadLocal&lt;Integer&gt; money = new ThreadLocal&lt;Integer&gt;() { @Override protected Integer initialValue() { return 0; } }; /** * 存钱 * * @param money 金额 */ public void setMoney(Integer money) { this.money.set(getMoney() + money); } /** * 获取余额 * * @return 金额 */ public Integer getMoney() { return money.get(); }}//输出结果用户2存钱中 ...用户1存钱中 ...用户2存钱已存入 150元用户1存钱已存入 100元用户2当前余额 150元用户2存钱中 ...用户1当前余额 100元用户1存钱中 ...用户2存钱已存入 150元用户2当前余额 300元用户2存钱中 ...用户1存钱已存入 100元用户1当前余额 200元用户1存钱中 ...用户2存钱已存入 150元用户1存钱已存入 100元用户1当前余额 300元用户2当前余额 450元 (4) 实现原理① 在ThreadLocal类中定义了一个ThreadLocalMap对象 , 该对象是线程独有的 , 每一个线程都有一个ThreadLocalMap类型的变量threadLocals。② ThreadLocalMap内部有一个Entry对象 , Entry的key是ThreadLocal对象实例 , value就是共享变量副本。③ ThreadLocal的get方法就是根据ThreadLocal对象实例获取存在于ThreadLocalMap中的共享变量副本。③ ThreadLocal的set方法就是根据ThreadLocal对象实例修改存在于ThreadLocalMap中的共享变量副本。 2. 原子类(1) 简介和作用Java的java.util.concurrent.atomic包里面提供了很多可以进行原子操作的类 , 分为以下四类: 原子更新基本类型: AtomicInteger、AtomicBoolean、AtomicLong原子更新数组类型: AtomicIntegerArray、AtomicLongArray原子更新引用类型: AtomicReference、AtomicStampedReference等原子更新属性类型: AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。 (2) 示例i++操作是分为三个步骤的: 123int temp1 = i;int temp2 = temp1 + 1;i = temp2; 所以在多个线程对同个i同时i++时可能会出现问题 , 比如下面代码的输出结果预期应该都是2000: 1234567891011121314151617181920212223242526272829303132333435363738394041/* * @author WuZhengHua * @describe 原子类的使用 * @date 2020/03/29 */public class AtomicCtrl { public static void main(String[] args) throws InterruptedException { for (int i = 0; i &lt; 100; ++i) { Atomic atomic = new Atomic(); Thread thread1 = new Thread(atomic); Thread thread2 = new Thread(atomic); thread1.start(); thread2.start(); //加入到主线程方便数值统计 thread1.join(); thread2.join(); System.out.println(\"第\" + i + \"次,n的值为: \" + atomic.getN()); } }}class Atomic implements Runnable { private int n = 0; public int getN() { return n; } @Override public void run() { for (int i = 0; i &lt; 1000; ++i) { n++; } }}//输出结果第0次,n的值为: 2000第1次,n的值为: 1552第2次,n的值为: 2000... 但是我们发现结果中有一些并不是2000 , 这就是因为i++操作不是原子操作。这时候我们就可以使用原子类型: AtomicInteger 去代替int: 123456789101112131415161718class Atomic implements Runnable { //创建原子整型 , 并初始化值为0 private AtomicInteger n = new AtomicInteger(0); public AtomicInteger getN() { return n; } @Override public void run() { for (int i = 0; i &lt; 1000; ++i) { //获取到值再自增对应 i++ n.getAndIncrement(); } }}//输出结果 都是2000 这里补充一些AtomicInteger的常用API: getAndIncrement() : 对应n++incrementAndGet() : 对应++ngetAndDecrement() : 对应n–decrementAndGet() : 对应–n (3) CAS原理那么原子类型变量是如何实现原子操作的呢?答案就是CAS原理 , 我们来看看AtomicInteger的getAndIncrement()方法: 12345678/** * Atomically increments by one the current value. * * @return the previous value */public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1);} unsafe是Sun公司提供的可以进行原子操作的工具类 , 这里getAndAddInt传入三个参数分别是: AtomicInteger实例this , 地址偏移量valueOffset , 增加阶数1下面我们来看看unsafe.getAndAddInt()方法: 1234567public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;} 解释一下上面的几个参数:var1 : 是当前值nvar2 : 是地址偏移量var5 : 是n的期望值(这里就是加1之后的值)var4 : 递增间隔(这里是1)CAS(比较并交换)原理: ① getIntVolatile()方法是根据当前值和地址偏移量获取Java堆中的期望值。② compareAndSwapInt()方法是比对 当前值(var1) 和期望值(var5) 是否相同:i 如果相同 , 说明线程更改过该值 , 当前值(var1) = 期望值(var5) + 递增间隔(var4) , 返回true。ii 如果不同 , 说明线程没有更改过该值 , 当前值(var1) = 期望值(var5) , 返回false。 3. Lock(1) 可重入锁与不可重入锁不可重入锁: 线程多次请求它已经拥有的锁时会发生阻塞。可重入锁: 线程可以进入它已经拥有的锁的同步代码块。 (2) 读写锁多个线程可以同时读，读的时候不能写。多个线程不能同时写，写的时候不能读。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* * @author WuZhengHua * @describe 测试读写锁 * @date 2020/04/27 */public class ReadWriteLockDemo { private Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //定义读写锁 private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock(); //获取读操作锁 private ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock(); //获取写操作锁 private ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock(); public String get(String key) { readLock.lock(); //读操作加锁 try { System.out.println(Thread.currentThread().getName() + \" 读操作已加锁, 开始执行读操作...\"); Thread.sleep(3000); return map.get(key); } catch (Exception e) { e.printStackTrace(); return null; } finally { readLock.unlock(); //解锁 System.out.println(Thread.currentThread().getName() + \" 读操作已解锁, 读操作结束...\"); } } public void put(String key, String value) { writeLock.lock(); //写操作加锁 try { System.out.println(Thread.currentThread().getName() + \" 写操作已加锁, 开始执行写操作...\"); Thread.sleep(3000); map.put(key, value); } catch (Exception e) { e.printStackTrace(); } finally { writeLock.unlock(); //解锁 System.out.println(Thread.currentThread().getName() + \" 写操作已解锁, 写操作结束...\"); } } public static void main(String[] args) { final ReadWriteLockDemo readWriteLockDemo = new ReadWriteLockDemo(); new Thread(\"写线程1\") { @Override public void run() { readWriteLockDemo.put(\"key1\", \"value1\"); } }.start(); new Thread(\"读线程1\") { @Override public void run() { System.out.println(readWriteLockDemo.get(\"key1\")); } }.start(); new Thread(\"写线程2\") { @Override public void run() { readWriteLockDemo.put(\"key1\", \"value1\"); } }.start(); new Thread(\"读线程2\") { @Override public void run() { System.out.println(readWriteLockDemo.get(\"key1\")); } }.start(); new Thread(\"读线程3\") { @Override public void run() { System.out.println(readWriteLockDemo.get(\"key1\")); } }.start(); }}//运行结果写线程1 写操作已加锁, 开始执行写操作...写线程1 写操作已解锁, 写操作结束...读线程1 读操作已加锁, 开始执行读操作...读线程1 读操作已解锁, 读操作结束...value1写线程2 写操作已加锁, 开始执行写操作...写线程2 写操作已解锁, 写操作结束...读线程2 读操作已加锁, 开始执行读操作...读线程3 读操作已加锁, 开始执行读操作...读线程3 读操作已解锁, 读操作结束...value1读线程2 读操作已解锁, 读操作结束...value1 4. volatile关键字(1) 作用一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义: ① 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其它线程来说是立即可见的。② 禁止进行指令重排序 补充一下何为指令重排序: 1234int i = 0;i = 1;i = 2;i = 3; 如果变量i没有被volatile修饰，那么JVM在编译期会对代码进行优化，即i = 1;和i = 2;这两句代码是无效的，会直接忽略掉。进行了指令重排序。但是如果i被volatile修饰，有关i操作的代码都会被严格执行。这就是禁止了指令重排序。 (2) 使用条件① 对变量的写操作不依赖于当前值 123//错误例子volatile int i = 0;i = i + 1; //这里对于i的写操作依赖了i，所以不能使用volatile关键字修饰 ② 该变量没有包含在具有其它变量的不变式中 1234//错误例子volatile int i = 0;int j = 1;j = i + j; //这里j和i同时出现在不变式中，不能使用volatile关键字修饰 (3) 应用场景 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"线程","slug":"线程","permalink":"https://holuyi.gitee.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"多线程与并发1","slug":"多线程与并发1","date":"2020-07-22T07:07:36.000Z","updated":"2020-07-22T07:26:24.098Z","comments":true,"path":"2020/07/22/多线程与并发1/","link":"","permalink":"https://holuyi.gitee.io/2020/07/22/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%911/","excerpt":"","text":"一. 并行与并发并行: 两个事件同一时间时进行并发: 两个事件同个时间段内进行 二. 进程与线程进程: 正在运行的程序的实例 , 进程是线程的容器。线程: 进程内部的一个独立执行单元 , 每个进程可以并发多个线程组成。多线程: 多个线程并发执行。 三. 线程创建Java中的四种线程创建方式: 继承Thread类实现Runnable接口实现Callable接口线程池 1. 继承Thread类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* * @author WuZhengHua * @describe 继承Thread创建线程 * @date 2020/03/24 */public class MyThread extends Thread { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(\" MyThread执行了: \" + new Date().getTime()); try { Thread.sleep(50); //当前线程睡眠50ms } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { new MyThread().start(); for (int i = 0; i &lt; 10; i++) { System.out.println(\" 主线程执行了: \" + new Date().getTime()); try { Thread.sleep(50); //当前线程睡眠50ms } catch (InterruptedException e) { e.printStackTrace(); } } }}//输出结果 MyThread执行了: 1585035565928 主线程执行了: 1585035565928 主线程执行了: 1585035565982 MyThread执行了: 1585035565982 MyThread执行了: 1585035566044 主线程执行了: 1585035566044 MyThread执行了: 1585035566098 主线程执行了: 1585035566098 主线程执行了: 1585035566160 MyThread执行了: 1585035566160 主线程执行了: 1585035566214 MyThread执行了: 1585035566214 MyThread执行了: 1585035566283 主线程执行了: 1585035566283 主线程执行了: 1585035566345 MyThread执行了: 1585035566345 MyThread执行了: 1585035566399 主线程执行了: 1585035566399 主线程执行了: 1585035566461 MyThread执行了: 1585035566461 2. 实现Runnable接口1234567891011121314151617181920/* * @author WuZhengHua * @describe 实现Runnable接口创建线程 * @date 2020/03/24 */public class MyRunnable implements Runnable { @Override public void run() { System.out.println(\"MyRunnable线程执行了\"); } public static void main(String[] args) { //传入Runnable实现类和自定义线程名称 Thread thread = new Thread(new MyRunnable(),\"MyRunnable\"); thread.start(); }}//输出结果MyRunnable线程执行了 3. 实现Callable接口这种方式创建的线程需要依赖FutureTask类 , 与上面两个不同的是 , 该方式可以获得线程执行完之后的返回值。 12345678910111213141516171819202122232425262728/* * @author WuZhengHua * @describe 实现Callable接口创建线程 * @date 2020/03/24 */public class MyCallable implements Callable&lt;String&gt; { @Override public String call() throws Exception { System.out.println(\"MyCallable线程执行了\"); return \"MyCallable-return\"; } public static void main(String[] args) { FutureTask futureTask = new FutureTask(new MyCallable()); futureTask.run(); Object o = null; try { o = futureTask.get(); } catch (Exception e) { e.printStackTrace(); } System.out.println(o); }}//输出结果MyCallable线程执行了MyCallable-return 4. 线程池首先我们来了解一下什么是线程池 , 以及其内部有什么构成: Java提供了线程池以及操作线程池的工具类 , 这些类的关系如下: 通过线程池创建对象: 123456789101112/* * @author WuZhengHua * @describe 通过线程池创建对象 * @date 2020/03/24 */public class MyThreadPool { public static void main(String[] args) { //FixedThreadPool固定线程数的线程池 , 这里创建一个10个线程的线程池 ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new MyRunnable()); //创建线程 , 传入线程 }} 四. 线程的状态学过操作系统这门课的同学应该都知道 , 线程分为五个状态: 初始状态-就绪状态-运行状态-阻塞状态-终止状态 , 下面我用一幅图来说明这五个状态的关系(图片出自&lt;&lt;码出高效 Java开发手册&gt;&gt;) 五. 线程安全问题如果一段代码单线程运行的结果跟多线程运行的结果不一致 , 就说明这个多线程存在安全问题 , 在开发中我们要避免这种线程安全问题 , 看一段代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * @author WuZhengHua * @describe 票类,可以执行卖票操作 * @date 2020/03/24 */public class Ticket implements Runnable { private int amount = 100; @Override public void run() { //不停卖票 while (true) { if(amount &lt;= 0){ break; } //售卖电影票 try { //让线程睡眠100ms Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } //打印售出的电影票编号 , 并且数量减 String name = Thread.currentThread().getName(); //获取到线程名称 System.out.println(name + \"售出电影票,编号: \" + amount--); } } public static void main(String[] args) { Ticket ticket = new Ticket(); Thread thread1 = new Thread(ticket, \"窗口1\"); Thread thread2 = new Thread(ticket, \"窗口2\"); Thread thread3 = new Thread(ticket, \"窗口3\"); thread1.start(); thread2.start(); thread3.start(); }}//输出结果...窗口2售出电影票,编号: 10窗口1售出电影票,编号: 8窗口3售出电影票,编号: 9窗口1售出电影票,编号: 7窗口3售出电影票,编号: 5窗口2售出电影票,编号: 6窗口1售出电影票,编号: 4窗口2售出电影票,编号: 3窗口3售出电影票,编号: 4窗口3售出电影票,编号: 2窗口2售出电影票,编号: 1窗口1售出电影票,编号: 0窗口3售出电影票,编号: -1 从结果中我们看出 , 有些电影票被卖了多次(显然不符合逻辑) , 到最后甚至出现了0和-1的情况 , 原因就是因为Ticket类的amount变量被肆无忌惮地修改了 , 多个线程对共享数据同时具有写操作就是多线程安全问题。 六. 解决线程安全问题Java给我们提供了七种多线程同步的方式 , 这里我使用上面的例子来解决线程安全问题: 1.同步代码块(synchronized)创建一个锁对象 , 该对象可以理解为钥匙 , 一旦钥匙被某个线程拿到 , 其它线程就无法执行同步代码块 , 关键代码实现如下: 12345678910111213141516171819202122232425262728293031323334//创建一个锁对象,相当于钥匙private final Object object = new Object();@Overridepublic void run() { //使用同步代码块,这里传进去一个锁对象 synchronized (object) { //不停卖票 while (true) { if(amount &lt;= 0){ break; } //售卖电影票 try { //让线程睡眠100ms Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } //打印售出的电影票编号 , 并且数量减 String name = Thread.currentThread().getName(); //获取到线程名称 System.out.println(name + \"售出电影票,编号: \" + amount--); } } }//输出结果...窗口1售出电影票,编号: 7窗口1售出电影票,编号: 6窗口1售出电影票,编号: 5窗口1售出电影票,编号: 4窗口1售出电影票,编号: 3窗口1售出电影票,编号: 2窗口1售出电影票,编号: 1 这里锁对象被第一个线程(窗口1)拿到了 , 且循环过程中没有释放过锁对象 , 所以其它线程就无法执行同步代码块中的代码(变成单线程执行)。 2.同步方法(synchronized)synchronized关键字也可以修饰方法(静态方法和非静态方法都可以) , 我们在上面代码的基础上定义一个同步方法: 123456789101112131415161718192021222324252627282930313233343536373839/** * 在方法前加synchronized关键字 , * 本质上也是创建了一个锁对象 * 如果该方法是非静态方法,锁对象就是当前方法的实例new Ticket() * 如果该方法时静态方法,锁对象就是当前静态方法所在的类Ticket.class */private synchronized void saleTicket() { if(amount &lt;= 0){ break; } //售卖电影票 try { //让线程睡眠100ms Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } //打印售出的电影票编号 , 并且数量减 String name = Thread.currentThread().getName(); //获取到线程名称 System.out.println(name + \"售出电影票,编号: \" + amount--);}@Overridepublic void run() { while (true) { //这个方法就是只允许一个线程访问的同步方法 saleTicket(); }}//输出结果...窗口1售出电影票,编号: 7窗口1售出电影票,编号: 6窗口1售出电影票,编号: 5窗口1售出电影票,编号: 4窗口1售出电影票,编号: 3窗口1售出电影票,编号: 2窗口1售出电影票,编号: 1 3.同步锁通过上面两种方式 , 都是使用一个锁对象进行线程同步的 , Java为了优化这种同步方式, 可以检测锁的状态 , 体现面向对象 , 也提供了锁的机制 。Java提供了很多种锁 , 这里我们先以重入锁(ReenreantLock)为例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 创建重入锁 , 参数标识是否为公平锁 , * 这里设置为公平锁 , 每个线程都公平拥有执行权 , 所有线程都可以主动拿到这个锁 * 非公平锁(独占锁) , 默认值 , 一旦某个线程拿到锁之后就一直持有执行权直到主动释放 */private Lock lock = new ReentrantLock(true);@Overridepublic void run() { /* * 加锁方法 , 这个方法跟解锁方法unlock必须要成对出现 , 否则会出现死锁 * 所以我们经常使用try-finally语句块去保证不会出现死锁现象 */ while (true) { lock.lock(); try { //不停卖票,直到数量为0 if(amount &lt;= 0){ break; } //售卖电影票 try { //让线程睡眠100ms Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } //打印售出的电影票编号 , 并且数量减 String name = Thread.currentThread().getName(); //获取到线程名称 System.out.println(name + \"售出电影票,编号: \" + amount--); } finally { //执行解锁 lock.unlock(); } }}//输出结果...窗口3售出电影票,编号: 8窗口1售出电影票,编号: 7窗口2售出电影票,编号: 6窗口3售出电影票,编号: 5窗口1售出电影票,编号: 4窗口2售出电影票,编号: 3窗口3售出电影票,编号: 2窗口1售出电影票,编号: 1 4.特殊域变量(volatile)5.局部变量(ThreadLocal)6.阻塞队列(LinkedBlockingQueue)7.原子变量(Atomic*)七. 线程死锁1. 什么是死锁死锁是指多个线程因竞争资源而造成的一种僵局(互相等待) , 若无外力作用 , 这些进程都将无法向前推进。 2. 死锁产生的必要条件(1) 互斥条件进程要求对所分配的资源(如打印机)进行排他性控制 , 即在一段时间内某资源仅为一个线程所占有。此时若有其它线程请求该资源 , 则请求进程只能等待。(2) 不可剥夺条件进程所获得的资源在未使用完毕之前 , 不能被其他线程强行夺走 , 即只能由获得该资源的进程自己来释放(只能主动释放)。(3) 请求与保持条件进程已经保持了至少一个资源 , 但又提出了新的资源请求 , 而该资源已被其他进程占有 , 此时请求进程被阻塞 , 但对自己已获得的资源保持不放。(4) 循环等待条件存在一种进程资源的循环等待链 , 链中每一个进程已获得的资源同时被链中下一个进程所请求。 八. 线程通讯1. 为什么要使用线程通讯多线程并发执行时 , 默认情况下CPU是随机切换线程执行的 , 有时我们希望CPU按照我们安排的规律去执行线程 , 这时就需要线程之间协调通信。 2. 线程通讯方式线程间通讯常用方式有四种: (1) 休眠唤醒方式① Object 的 wait()、notify()、notifyAll()② Condition 的 await()、signal()、signalAll() 案例: 创建两个线程 , 一个线程打印0-10以内的奇数 , 另一个线程打印0-10以内的偶数 , 两个线程按1-10的顺序交替打印。 ① 使用Object实现 使用Object的wait()和notify()实现线程休眠和唤醒依赖synchronized关键字 , Object就是锁对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//存放待打印的数private int i = 0;//使用Object的方法进行休眠唤醒private final Object obj = new Object();/** * 奇数打印方法 , 由奇数线程调用 */public void odd() { while (i &lt; 10) { /** * 注意这里别忘了使用synchronized关键字 * 不然会报异常java.lang.IllegalMonitorStateException */ synchronized (obj) { if (i % 2 != 0) { //奇数,输出出来并加一 System.out.println(\"奇数: \" + i++); //唤醒偶数线程 obj.notify(); } else { try { //等待偶数线程执行 obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } }}//..偶数打印方法类似,这里省略了public static void main(String[] args) { //创建当前实例 final PrintOddAndEven printOddAndEven = new PrintOddAndEven(); //开启奇数线程 Thread oddThread = new Thread(new Runnable() { @Override public void run() { printOddAndEven.odd(); } }); //开启偶数线程 Thread evenThread = new Thread(new Runnable() { @Override public void run() { printOddAndEven.even(); } }); oddThread.start(); evenThread.start();}//输出结果偶数: 0奇数: 1偶数: 2奇数: 3偶数: 4奇数: 5偶数: 6奇数: 7偶数: 8奇数: 9 ② 使用Condition对象 Condition是依赖Lock对象进行线程休眠和唤醒的 , 这也是跟Object方式的区别 , 同样使用上面的例子 , 改用Condition进行线程休眠唤醒 , 参照上例 , 部分代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 创建Lock对象,注意这里是非公平锁 */private Lock lock = new ReentrantLock(false);private Condition condition = lock.newCondition();/** * 奇数打印方法 , 由奇数线程调用 */public void odd() { while (i &lt; 10) { //加锁 lock.lock(); try { if (i % 2 != 0) { //奇数,输出出来并加一 System.out.println(\"奇数: \" + i++); //唤醒偶数线程 condition.signal(); } else { try { //等待偶数线程执行 condition.await(); } catch (InterruptedException e) { e.printStackTrace(); } } } finally { //释放锁 lock.unlock(); } }}//输出结果偶数: 0奇数: 1偶数: 2奇数: 3偶数: 4奇数: 5偶数: 6奇数: 7偶数: 8奇数: 9 (2) CountDownLatch用于某个线程A等待若干其它线程执行完之后 , 它才执行。(即一等多)案例: 一个教练等待三个运动员准备完成再开始训练 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* * @author WuZhengHua * @describe CountDownLatch的使用 * @date 2020/03/26 */public class CoachWaitRacer { //创建CountDownLatch对象,构造函数需要传入需要等待的线程数量 private CountDownLatch countDownLatch = new CountDownLatch(3); /** * 教练 */ public void coach() { String name = Thread.currentThread().getName(); try { Thread.sleep(1000); System.out.println(name + \"准备完毕,等待运动员...\"); countDownLatch.await(); System.out.println(\"运动员全部到齐,开始训练!\"); } catch (InterruptedException e) { e.printStackTrace(); } } /** * 运动员 */ public void racer() { String name = Thread.currentThread().getName(); System.out.println(name + \"开始准备...\"); try { Thread.sleep(1000); System.out.println(name + \"准备完毕!\"); //调用计数器减一 countDownLatch.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } } public static void main(String[] args) { final CoachWaitRacer coachWaitRacer = new CoachWaitRacer(); Thread thread = new Thread(new Runnable() { @Override public void run() { coachWaitRacer.coach(); } }, \"教练\"); Thread thread1 = new Thread(new Runnable() { @Override public void run() { coachWaitRacer.racer(); } }, \"运动员1\"); Thread thread2 = new Thread(new Runnable() { @Override public void run() { coachWaitRacer.racer(); } }, \"运动员2\"); Thread thread3 = new Thread(new Runnable() { @Override public void run() { coachWaitRacer.racer(); } }, \"运动员3\"); thread.start(); thread1.start(); thread2.start(); thread3.start(); }}//输出结果运动员1开始准备...运动员3开始准备...运动员2开始准备...运动员2准备完毕!教练准备完毕,等待运动员...运动员1准备完毕!运动员3准备完毕!运动员全部到齐,开始训练! (3) CyclicBarrier一组线程等待至某个状态之后再全部执行。(同时阻塞)案例: 运动员准备完成都到了起跑线才能开始比赛。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * @author WuZhengHua * @describe CyclicBarrier的使用 * @date 2020/03/26 */public class RacerGo { /** * 创建cyclicBarrier对象,传入线程组的线程数,即需要互相等待的线程数 */ CyclicBarrier cyclicBarrier = new CyclicBarrier(3); public void racerStart() { String name = Thread.currentThread().getName(); try { Thread.sleep(1000); System.out.println(name + \"准备完毕\"); //调用await方法,只有当三个线程到达同一状态时才继续往下执行(即三个线程都执行到该方法) cyclicBarrier.await(); System.out.println(new Date().getTime() + \" 跑!\"); } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } } public static void main(String[] args) { final RacerGo racerGo = new RacerGo(); new Thread(new Runnable() { @Override public void run() { racerGo.racerStart(); } }, \"运动员1\").start(); new Thread(new Runnable() { @Override public void run() { racerGo.racerStart(); } }, \"运动员2\").start(); new Thread(new Runnable() { @Override public void run() { racerGo.racerStart(); } }, \"运动员3\").start(); }}//输出结果运动员2准备完毕运动员3准备完毕运动员1准备完毕1585233005512 跑!1585233005512 跑!1585233005512 跑! (4) Semaphore用于控制对某组资源的访问权限。案例: 假如有5个工人 , 3台机器 , 每台机器只允许一人使用。即5个线程使用3个资源 , 每个资源只能由一个线程占有。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * @author WuZhengHua * @describe Semaphore的使用 * @date 2020/03/27 */public class WorkersAndMachine { Semaphore semaphore = new Semaphore(3); //三台机器,三个资源 /** * 工人工作 */ public void doWork() { String name = Thread.currentThread().getName(); System.out.println(name + \"准备工作,请求一台机器 \"+new Date().getTime()); try { //请求一个资源 semaphore.acquire(); System.out.println(name+\"拿到机器,开始工作... \"+new Date().getTime()); //工作了1000ms Thread.sleep(2000); //使用完毕,释放一个资源 semaphore.release(); System.out.println(name + \"完成工作,释放机器! \"+new Date().getTime()); } catch (InterruptedException e) { e.printStackTrace(); } } public static void main(String[] args) { final WorkersAndMachine workersAndMachine = new WorkersAndMachine(); //5个工人,创建5个线程 for (int i = 0; i &lt; 5; ++i) { new Thread(new Runnable() { @Override public void run() { workersAndMachine.doWork(); } }, \"工人\" + i).start(); } }}//输出结果工人1准备工作,请求一台机器 1585323284818工人2准备工作,请求一台机器 1585323284818工人1拿到机器,开始工作... 1585323284818工人0准备工作,请求一台机器 1585323284818工人4准备工作,请求一台机器 1585323284818工人3准备工作,请求一台机器 1585323284818工人0拿到机器,开始工作... 1585323284818工人2拿到机器,开始工作... 1585323284818工人1完成工作,释放机器! 1585323286823工人4拿到机器,开始工作... 1585323286823工人0完成工作,释放机器! 1585323286823工人3拿到机器,开始工作... 1585323286823工人2完成工作,释放机器! 1585323286823工人3完成工作,释放机器! 1585323288829工人4完成工作,释放机器! 1585323288829 Question1. 使用多线程的目的是什么?充分利用cpu资源 , 并发进行多个任务 2. 单核CPU机器上适不适合多线程?适合 , 如果是单核CPU , 在线程中也可能需要等待IO , 此时CPU就空闲下来了 , 可以给其它线程使用。但是一定要考虑其创建线程+销毁线程的时间是否超过了任务执行时间 , 考虑是否值得创建线程。 3. 线程什么时候会让出CPU?(1) 阻塞时 wait await 等待IO(2) sleep(3) yield(4) 线程结束 4. 线程是什么?一组代码执行流 , 完成一组代码的执行这一组代码 , 我们可以称为一个任务 5. CPU做的是什么工作?执行代码 6. 线程是不是越多越好?(1) 线程在Java中是一个对象 , 每一个Java线程都需要一个操作系统线程支持。线程创建、销毁都需要时间。如果创建时间+销毁时间 &gt; 任务执行时间 , 就很不合算*。(2) Java对象占用堆内存 , 操作系统线程占用系统内存 , 根据JVM规范 , 一个线程默认最大栈大小为1M , 这个栈空间是需要从系统内存中分配的。*线程过多 , 会消耗很多内存。(3) 操作系统需要频繁切换线程上下文(所有线程都需要被执行) , 影响性能。 7. 如何正确使用多线程?多线程的目的: 充分利用CPU并发执行代码。线程的本质: 将代码提交给CPU执行。用合适数量的线程不断运送代码即可。这些合适数量的线程就构成了一个池-线程池。 8. synchronized和Lock的区别是什么?(1) synchronized是Java内置的关键字 , 是在JVM层面上的。而Lock是一个Java类。(2) synchronized无法判断是否获取锁的状态。Lock可以判断是否获取到锁。(3) synchronized在执行完后会自动释放锁。而Lock必须要手动释放锁 , 否则会出现死锁。(4) synchronized的锁可重入、不可中断、非公平。Lock锁可重入、可判断、可设置是否公平。(5) synchronized适合给少量代码加锁。Lock适合给大量代码加锁。 7. wait()和sleep()的区别是什么? wait() sleep() 同步 只能在同步上下文中调用wait方法 , 否则或抛出IllegalMonitorStateException异常 不需要再同步方法或同步代码块中使用 作用对象 wait方法定义在Object类中 , 作用与(锁)对象本身 sleep方法定义在java.lang.Thread中 , 作用于当前线程 释放锁资源 是 , 调用wait()方法后锁资源就被释放了 否 , 调用sleep()后仍然占有锁资源 唤醒条件 其它线程调用notify()或者notifyAll()方法 超时或者调用interrupt()方法体 方法属性 Object对象的实例方法 Thread类的静态方法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"线程","slug":"线程","permalink":"https://holuyi.gitee.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"什么是微服务，SpringBoot和SpringCloud的关系","slug":"什么是微服务，SpringBoot和SpringCloud的关系","date":"2020-07-21T18:41:14.000Z","updated":"2020-07-22T07:23:36.218Z","comments":true,"path":"2020/07/22/什么是微服务，SpringBoot和SpringCloud的关系/","link":"","permalink":"https://holuyi.gitee.io/2020/07/22/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%8CSpringBoot%E5%92%8CSpringCloud%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"","text":"什么是微服务就目前而言对于微服务业界没有一个统一的,标准的定义.但通常而言,微服务是一种架构模式或者说是一种架构风格,它提倡单一应用程序划分为一组小的服务,每个服务在其独立的自己的进程中,服务之间相互协调,互相配合,为用户提供最终价值.服务之间采用轻量级的通信机制互相沟通(基于Http的Restful API)每个服务都围绕着具体的业务进行构建,并且能够被独立的部署到生产环境,类生产环境进行构建,可以有一个非常轻量级的集中式管理来协调这些服务,可以使用不同的语言来编写服务,也可以使用不同的数据存储. 微服务与微服务架构? 微服务强调的是服务的大小,关注的是点,是具体解决某一个问题/提供落地对象服务的一个服务应用, 狭义的看,可以看做Eclipse中的一个个微服务工程. 微服务架构为一种架构模式.他提倡将单一应用程序分成一组小的服务,服务之间互相协调,互相配合,为用户提供最终价值. 每个服务运行在其独立的进程中,服务于服务间采用轻量级的通信机制互相协作(通常是Http 的Restful API) 每一个服务 都围绕着具体业务进行构建,并且能够被独立的部署到生产环境,类生产环境中.另外,应当尽量避免统一的,集中式的服务管理机制, 对具体的一个服务而言,应根据业务上下文,选择合适的语言,工具对其进行构建. SpringCloud 是什么? 基于SpringBoot提供了一套为微服务(microservices)解决方案,包括服务注册与发现, 配置中心,全链路监控,服务网关,负载均衡,熔断器等组件,除了基于NetFlix的开营组件做 高度抽象之外,还有一些选型中立了的开源组件. 分布式微服务架构下的一站式解决方案,是各个微服务架构落地技术的结合体,俗称为微服务全家桶. SpringBoot和SpringCloud的关系和区别 SpringBoot专注于方便的开发单个个体微服务 SpringCloud是关注于全局的微服务协调治理框架,它将SpringBoot开发的一个个单体微服务整合并管理起来.为各个微服务之间提供配置管理,服务发现,断路器,路由,微代理,事件总线,决策竞选,分布式会话等集成服务. SpringBoot可以离开SpringCloud单独使用,而SpringCloud离不开SpringBoot document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://holuyi.gitee.io/tags/springboot/"},{"name":"springcloud","slug":"springcloud","permalink":"https://holuyi.gitee.io/tags/springcloud/"}]},{"title":"将maven源改为国内阿里云镜像","slug":"将maven源改为国内阿里云镜像","date":"2020-07-21T18:41:02.000Z","updated":"2020-07-22T07:23:41.248Z","comments":true,"path":"2020/07/22/将maven源改为国内阿里云镜像/","link":"","permalink":"https://holuyi.gitee.io/2020/07/22/%E5%B0%86maven%E6%BA%90%E6%94%B9%E4%B8%BA%E5%9B%BD%E5%86%85%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F/","excerpt":"","text":"12345678910111213141516171819202122&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;localRepository/&gt; &lt;interactiveMode/&gt; &lt;usePluginRegistry/&gt; &lt;offline/&gt; &lt;pluginGroups/&gt; &lt;servers/&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public &lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;proxies/&gt; &lt;profiles/&gt; &lt;activeProfiles/&gt;&lt;/settings&gt; 12345678910111213&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public &lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"maven","slug":"maven","permalink":"https://holuyi.gitee.io/tags/maven/"}]},{"title":"SSM中各层作用及关系","slug":"SSM中各层作用及关系","date":"2020-07-21T18:40:49.000Z","updated":"2020-07-22T07:26:40.219Z","comments":true,"path":"2020/07/22/SSM中各层作用及关系/","link":"","permalink":"https://holuyi.gitee.io/2020/07/22/SSM%E4%B8%AD%E5%90%84%E5%B1%82%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%85%B3%E7%B3%BB/","excerpt":"","text":"持久层：DAO层（mapper层）（属于mybatis模块） DAO层：主要负责与数据库进行交互设计，用来处理数据的持久化工作。 DAO层的设计首先是设计DAO的接口，也就是项目中看到的Dao包。 然后在Spring的xml配置文件中定义此接口的实现类，就可在其他模块中调用此接口来进行数据业务的处理，而不用关心接口的具体实现类是哪个类，这里往往用到的就是反射机制，DAO层的jdbc.properties数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。 有的项目Dao层，写成mapper，当成一个意思理解。 业务层：Service层（属于spring模块） Service层：主要负责业务模块的逻辑应用设计。也就是项目中看到的Service包。 Service层的设计首先是设计接口，再设计其实现的类。也就是项目中看到的service+impl包。 接着再在Spring的xml配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。 最后通过调用DAO层已定义的接口，去实现Service具体的实现类。 Service层的业务实现，具体要调用到已定义的DAO层的接口。 控制层/表现层：Controller层（Handler层） （属于springMVC模块） Controller层：主要负责具体的业务模块流程控制，也就是看到的controller包。 Controller层通过要调用Service层的接口来控制业务流程，控制的配置也同样是在Spring的xml配置文件里面，针对具体的业务流程，会有不同的控制器。 View层 （属于springMVC模块） 负责前台jsp页面的展示，此层需要与Controller层结合起来开发。 Jsp发送请求，controller接收请求，处理，返回，jsp回显数据。 各层之间的联系 DAO层，Service层这两个层次可以单独开发，互相的耦合度很低。 Controller，View层耦合度比较高，因而要结合在一起开发。也可以听当做两层来开发，这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，项目会显得清晰简单。 值得注意的是，Service逻辑层设计：Service层是建立在DAO层之上的，在Controller层之下。因而Service层应该既调用DAO层的接口，又提供接口给Controller层的类来进行调用，它处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。 SSM框架实现一个web程序主要使用到如下三个技术： Spring：用到注解和自动装配，就是Spring的两个精髓IOC(反向控制)和 AOP(面向切面编程)。 SpringMVC：用到了MVC模型，将流程控制代码放到Controller层处理，将业务逻辑代码放到Service层处理。 Mybatis：用到了与数据库打交道的层面，dao（mapper）层，放在所有的逻辑之后，处理与数据库的CRUD相关的操作。 开发项目的时候，需要完成一个功能模块 先写实体类entity，定义对象的属性，（可以参照数据库中表的字段来设置，数据库的设计应该在所有编码开始之前）。 写Mapper.xml（Mybatis），其中定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。 写Mapper.java/Dao.java，将Mapper.xml中的操作按照id映射成Java函数。实际上就是Dao接口，二者选一即可。 写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。 写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。 写JSP页面调用，请求哪些参数，需要获取什么数据。 面向对象——三层架构（表现层、业务层、持久层）三层架构：即表现层、业务层、持久层。 持久层：采用DAO模式，建立实体类和数据库表映射（ORM映射）。也就是哪个类对应哪个表，哪个属性对应哪个列。持久层的目的就是，完成对象数据和关系数据的转换。 业务层：采用事务脚本模式。将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作，即保证同时成功或同时失败。避免部分成功部分失败引起的数据混乱操作。 表现层：采用MVC模式。M称为模型，也就是实体类。用于数据的封装和数据的传输。V为视图，也就是GUI组件，用于数据的展示。C为控制，也就是事件，用于流程的控制 业务层接口的设计原则：一个实体类一个接口，一次提交一个业务方法。业务方法的参数自表现层。 持久层接口的设计原则：一个实体类一个接口，一次数据库操作一个持久方法。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"sring","slug":"sring","permalink":"https://holuyi.gitee.io/tags/sring/"},{"name":"springmvc","slug":"springmvc","permalink":"https://holuyi.gitee.io/tags/springmvc/"},{"name":"mybatis","slug":"mybatis","permalink":"https://holuyi.gitee.io/tags/mybatis/"}]},{"title":"Redis基础学习","slug":"Redis基础学习","date":"2020-07-21T18:40:31.000Z","updated":"2020-07-22T07:26:44.635Z","comments":true,"path":"2020/07/22/Redis基础学习/","link":"","permalink":"https://holuyi.gitee.io/2020/07/22/Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"Redis基础学习Redis 概念: Redis是一款高性能的NoSQL系列的非关系型数据库 命令操作: Redis的数据结构: Redis存储的是: key-value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构: 字符串类型: String 哈希类型: hash(Map类型) 列表类型: list(Linkedlist) 集合类型: set 有序列表类型: sortedset 字符串类型 string 存储: set key value 获取: get key 删除: del key","text":"Redis基础学习Redis 概念: Redis是一款高性能的NoSQL系列的非关系型数据库 命令操作: Redis的数据结构: Redis存储的是: key-value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构: 字符串类型: String 哈希类型: hash(Map类型) 列表类型: list(Linkedlist) 集合类型: set 有序列表类型: sortedset 字符串类型 string 存储: set key value 获取: get key 删除: del key 哈希类型 hash 存储: hset key field value 获取: hget key field 删除: hdel key field 获取hash中的所有键和值: hgetall key 列表类型 list 存储: lpush key value: 从左添加 rpush key value: 从右添加 获取: lrange key start end: 范围获取(0 -1代表获取全部) 删除: lpop key: 删除列表最左边的元素，并返回 rpop key: 删除列表最右边的元素，并返回 集合类型 set: 不允许重复元素(且无序) 存储: sadd key value value1 value2 …. 获取: smembers key: 获取set集合中的所有元素 删除: srem key value: 删除set集合中的某个元素 有序集合类型 sortedset: 不允许有重复元素，不同的是每个元素会有一个double类型的分数(权重)，按照此分数进行排序 存储: zadd key score value 获取: zrange key start end 删除: zrem key value 通用命令 keys * : 查询所有的键 type key : 获取键对应的value的类型 del key: 删除指定的key value 持久化 Redis是一个内存数据库，当Redis服务器或电脑重启，数据会丢失，我们可以将Redis内存中的数据持久化保存到硬盘文件中 Redis持久化机制 RDB: 默认方式，不需要进行配置，默认使用 在一定间隔事件中，检测key的变化情况，然后持久化数据 编辑redis.windows.conf文件 save 900 1(15分钟有一个key变化就持久化) save 300 10 save 60 10000 重新启动redis服务器并指定conf cmd启动服务器: redis-server.exe redis.windows.conf AOF: 日志记录的方法，可以记录每一条命令的操作，然后持久化操作(不推荐) 编辑redis.windows.conf appendonly no(关闭aof) –&gt; appendonly yes appendfsync always: 每一次操作都进行持久化 appendfsync everysec: 每隔一秒都进行一次持久化 appendfsync no : 不进行持久化 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"redis","slug":"redis","permalink":"https://holuyi.gitee.io/tags/redis/"}]},{"title":"git 使用（ssh key创建和github使用）","slug":"git-使用（ssh-key创建和github使用）","date":"2020-07-17T18:38:48.000Z","updated":"2020-07-22T07:27:38.104Z","comments":true,"path":"2020/07/18/git-使用（ssh-key创建和github使用）/","link":"","permalink":"https://holuyi.gitee.io/2020/07/18/git-%E4%BD%BF%E7%94%A8%EF%BC%88ssh-key%E5%88%9B%E5%BB%BA%E5%92%8Cgithub%E4%BD%BF%E7%94%A8%EF%BC%89/","excerpt":"","text":"ssh用于验证，https://github.com/ 需要，https://www.cloudcontrol.com/onboarding/ssh也需要。git使用记录git是分布式的代码管理工具，远程的代码管理是基于ssh的，所以要使用远程的git则需要ssh的配置。 github的ssh配置如下： 一 、设置git的user name和email：12$ git config --global user.name \"xuhaiyan\"$ git config --global user.email \"haiyan.xu.vip@gmail.com\" 二、生成SSH密钥过程：1.查看是否已经有了ssh密钥：cd ~/.ssh如果没有密钥则不会有此文件夹，有则备份删除2.生存密钥： 123456789$ ssh-keygen -t rsa -C “haiyan.xu.vip@gmail.com”按3个回车，密码为空。Your identification has been saved in /home/tekkub/.ssh/id_rsa.Your public key has been saved in /home/tekkub/.ssh/id_rsa.pub.The key fingerprint is:……………… 最后得到了两个文件：id_rsa和id_rsa.pub 3.添加密钥到ssh：ssh-add 文件名 需要之前输入密码。4.在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。 打开https://github.com/ ，登陆xuhaiyan825，然后添加ssh。 5.测试：ssh git@github.com The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘github.com,207.97.227.239′ (RSA) to the list of known hosts.ERROR: Hi tekkub! You’ve successfully authenticated, but GitHub does not provide shell accessConnection to github.com closed. 三、 开始使用github1.获取源码： 1$ git clone git@github.com:billyanyteen/github-services.git 2.这样你的机器上就有一个repo了。3.git于svn所不同的是git是分布式的，没有服务器概念。所有的人的机器上都有一个repo，每次提交都是给自己机器的repo仓库初始化： 1git init 生成快照并存入项目索引： 1git add 文件,还有git rm,git mv等等…项目索引提交： 1git commit 4.协作编程：将本地repo于远程的origin的repo合并，推送本地更新到远程： 1git push origin master 更新远程更新到本地： 1git pull origin master 补充：添加远端repo： 1$ git remote add upstream git://github.com/pjhyett/github-services.git 重命名远端repo： 1$ git://github.com/pjhyett/github-services.git为“upstream” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://holuyi.gitee.io/tags/github/"}]},{"title":"使用Hexo+github搭建一个属于自己的服务器","slug":"使用Hexo+github搭建一个属于自己的服务器","date":"2020-05-31T18:41:27.000Z","updated":"2020-07-22T07:23:29.162Z","comments":true,"path":"2020/06/01/使用Hexo+github搭建一个属于自己的服务器/","link":"","permalink":"https://holuyi.gitee.io/2020/06/01/%E4%BD%BF%E7%94%A8Hexo+github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"安装Nodejsnode -v #查看node版本 npm -v #查看npm版本 npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器 cnpm -v #查看cnpm版本 cnpm install -g hexo-cli #安装hexo框架 hexo -v #查看hexo版本 mkdir blog #创建blog目录 cd blog #进入blog目录 sudo hexo init #生成博客 初始化博客 hexo s #启动本地博客服务 http://localhost:4000/ #本地访问地址 hexo n “我的第一篇文章” #创建新的文章 返回blog目录 hexo clean #清理 hexo g #生成 Github创建一个新的仓库 YourGithubName.github.io cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件 配置_config.ymlDeployment Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/YourGithubName/YourGithubName.github.io.git branch: master hexo d #部署到Github仓库里 https://YourGithubName.github.io/ #访问这个地址可以查看博客 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia #下载yilia主题到本地 #修改hexo根目录下的 _config.yml 文件 ： theme: yilia hexo c #清理一下 hexo g #生成 hexo d #部署到远程Github仓库 视频链接：https://www.bilibili.com/video/BV1Yb411a7ty?t=1486 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://holuyi.gitee.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://holuyi.gitee.io/tags/hexo/"}]},{"title":"hello world","slug":"hello world","date":"2020-05-31T18:32:06.000Z","updated":"2020-07-22T07:27:05.471Z","comments":true,"path":"2020/06/01/hello world/","link":"","permalink":"https://holuyi.gitee.io/2020/06/01/hello%20world/","excerpt":"","text":"记录第一条博客 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"hello world","slug":"hello-world","permalink":"https://holuyi.gitee.io/tags/hello-world/"}]}],"categories":[],"tags":[{"name":"-leancloud -hexo","slug":"leancloud-hexo","permalink":"https://holuyi.gitee.io/tags/leancloud-hexo/"},{"name":"测试","slug":"测试","permalink":"https://holuyi.gitee.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"线程","slug":"线程","permalink":"https://holuyi.gitee.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"springboot","slug":"springboot","permalink":"https://holuyi.gitee.io/tags/springboot/"},{"name":"springcloud","slug":"springcloud","permalink":"https://holuyi.gitee.io/tags/springcloud/"},{"name":"maven","slug":"maven","permalink":"https://holuyi.gitee.io/tags/maven/"},{"name":"sring","slug":"sring","permalink":"https://holuyi.gitee.io/tags/sring/"},{"name":"springmvc","slug":"springmvc","permalink":"https://holuyi.gitee.io/tags/springmvc/"},{"name":"mybatis","slug":"mybatis","permalink":"https://holuyi.gitee.io/tags/mybatis/"},{"name":"redis","slug":"redis","permalink":"https://holuyi.gitee.io/tags/redis/"},{"name":"github","slug":"github","permalink":"https://holuyi.gitee.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://holuyi.gitee.io/tags/hexo/"},{"name":"hello world","slug":"hello-world","permalink":"https://holuyi.gitee.io/tags/hello-world/"}]}